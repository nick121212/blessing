/**
 * Created by NICK on 2016/12/16.
 */

import { Server, Client } from "eureca.io";
import { EventEmitter } from "events";
import { Compose } from "./compose";
import _ from "lodash";

export class SpaRouter extends EventEmitter {
    constructor() {
        super();

        this.keys = {};
    }

    get eureca() {
        return null;
    }

    /**
     * 开始中间件
     */
    attach(app, spaEureca) {
        let fn = app.callback();

        spaEureca.eureca.exports = _.extend({}, spaEureca.eureca.exports || {});
        _.forEach(this.keys, (val, key) => {
            spaEureca.eureca.exports[key] = function(data) {
                let context = this;
                context.async = true;
                if (!context.retId) return;
                fn({
                    routerKey: key,
                    context: _.clone(context),
                    params: data || {},
                    proxy: spaEureca
                });
            };
        });

        return async(ctx, next) => {
            if (this.keys.hasOwnProperty(ctx.routerKey)) {
                await this.keys[ctx.routerKey](ctx, next);
            } else {
                await next();
            }
        };
    }

    /**
     * 添加路由方法
     */
    attachRouteToSocket(key, func) {
        this.keys[key] = func;
    }
}

export class SpaServer extends SpaRouter {
    constructor(config) {
        super();

        this._server = null;
        this._connections = {};

        this.init(config);
    }

    get eureca() {
        return this._server;
    }

    get connections() {
        return this._connections;
    }

    attach(app) {
        return super.attach(app, this);
    }

    init(config, events = {}) {
        this._server = new Server({
            transport: config.transport,
            allow: config.allow || []
        });
        this._server.exports = {};

        _.forEach(events, (fn, key) => {
            if (key !== "connect" && key !== "disconnect") {
                this._server.on(key, (data) => {
                    fn(this, data);
                });
            }
        });

        this._server.on("connect", (connection) => {
            this._connections[connection.id] = {
                socket: connection
            };
            this.emit("onconnect", connection, this._connections[connection.id]);
        });
        this._server.on("disconnect", (connection) => {
            if (this._connections[connection.id]) {
                delete this._connections[connection.id];
            }
            this.emit("ondisconnect", connection);
        });
        return this._server;
    }
}

export class SpaClient extends SpaRouter {
    constructor(config) {
        super();
        this._client = null;
        this.init(config);
    }

    get connections() {
        return {};
    }

    get eureca() {
        return this._client;
    }

    get proxy() {
        if (this._client && this._client.isReady()) {
            return this._client.serverProxy;
        }
    }

    attach(app) {
        return super.attach(app, this);
    }

    init(config, events = {}) {
        this._client = new Client({
            uri: config.uri,
            prefix: config.prefix || ""
        });

        _.forEach(events, (fn, key) => {
            this._client.on(key, (data) => {
                fn(this, data);
            });
        });

        this._client.on("ready", (proxy) => {
            this.emit("ready", proxy);
        });
    }
}

export class Spa extends Compose {
    constructor(_maxJobs) {
        super(_maxJobs);
    }

    onComplete(ctx) {
        if (ctx.err) {
            console.log("onComplete-----", ctx.err);
        }
        console.log("onComplete-----", ctx.routerKey, ctx.app.jobs, "retId:", ctx.context.retId);
        super.onComplete(ctx);
        ctx.context.return && ctx.context.return(ctx.err || ctx.body);
    }

    initClient(config) {
        this.spaClient = new SpaClient(config);
    }

    initServer(config, app) {
        this.spaServer = new SpaServer(config);
        this.spaServer.eureca.attach(app);
    }
}