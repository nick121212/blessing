{"version":3,"sources":["webpack:///./~/angular-schema-form/dist/schema-form.js?4243"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,IAAI;AACvB;AACA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;;AAGL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qFAAoF;AACpF;;AAEA,kCAAiC;AACjC;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,wCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,oCAAmC,0BAA0B;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,uCAAsC,oCAAoC;AAC1E;AACA;AACA,2EAA0E;AAC1E,iGAAgG;AAChG;;AAEA;AACA,oCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAkG;AAClG;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;;AAEA,sBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;;AAE7B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB,kBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAS;;AAET,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC,sCAAqC;AACrC,oEAAmE,+BAA+B;AAClG;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C,wCAAuC,OAAO;AAC9C,yCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C,wCAAuC,OAAO;AAC9C,yCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,iBAAiB;AACnE;AACA;AACA,yCAAwC,OAAO;AAC/C,yCAAwC,OAAO;AAC/C;AACA,yCAAwC,IAAI;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,2EAA0E,wBAAwB;AAClG;AACA,0CAAyC;AACzC;;AAEA;AACA;AACA;AACA,yGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sFAAqF,wCAAwC;AAC7H;AACA,sFAAqF,+FAA+F;AACpL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA,sCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yEAAwE;AACxE;AACA;AACA,sDAAqD;AACrD;AACA,sDAAqD;AACrD;AACA,sDAAqD;AACrD;AACA,sDAAqD;AACrD;AACA;AACA;AACA;AACA,0CAAyC;AACzC;;AAEA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC,kCAAiC;AACjC;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA,iCAAgC;;AAEhC;AACA,2CAA0C;AAC1C,cAAa;;AAEb;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO,yCAAyC,4BAA4B;AAC/F;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC,kBAAkB;;AAElD;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA,oBAAmB,OAAO;AAC1B,qBAAoB,OAAO,sBAAsB;AACjD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,SAAS;AAC5B,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC,aAAa;AACtD,sCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA,gDAA+C,mBAAmB;AAClE,qBAAoB,WAAW,uCAAuC,gBAAgB;AACtF,qBAAoB,WAAW,qCAAqC,gBAAgB;AACpF,qBAAoB,WAAW,0CAA0C,gBAAgB;AACzF,qBAAoB,WAAW,qCAAqC,gBAAgB;AACpF;AACA;AACA,0CAAyC,kBAAkB,mBAAmB,kBAAkB;AAChG,yCAAwC,kBAAkB,mBAAmB,kBAAkB;AAC/F,oDAAmD,gBAAgB;AACnE;AACA,yDAAwD,sBAAsB;AAC9E,0DAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA,yCAAwC,cAAc,aAAa,iBAAiB;AACpF,wCAAuC,cAAc,aAAa,iBAAiB;AACnF;AACA;AACA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA,wBAAuB,IAAI;AAC3B,wBAAuB,IAAI;AAC3B,wBAAuB,OAAO;AAC9B,yBAAwB,OAAO;AAC/B;AACA,yBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,UAAS;;AAET,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B;AAC9B;AACA,gCAA+B,0BAA0B;AACzD,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,sCAAsC;AAC9E,sBAAqB;AACrB,kBAAiB;AACjB;AACA,yCAAwC,2BAA2B;AACnE,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B,kBAAkB;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,qBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA,6CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,sBAAqB;;AAErB,kBAAiB;AACjB;AACA;AACA,yBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA,0BAAyB;AACzB,sBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;;AAEA;AACA,yBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,iCAAiC;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB,4DAA2D,6CAA6C;AACxG;AACA,sBAAqB;AACrB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,+EAA8E,+BAA+B;AAC7G,kCAAiC;AACjC,gEAA+D,+BAA+B;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C,oCAAmC,OAAO;AAC1C,qCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C,oCAAmC,OAAO;AAC1C,qCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,iBAAiB;AAC/D;AACA;AACA,qCAAoC,OAAO;AAC3C,qCAAoC,OAAO;AAC3C;AACA,qCAAoC,IAAI;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6DAA4D;AAC5D;AACA;AACA;AACA,0CAAyC;AACzC;AACA,0CAAyC;AACzC;AACA,0CAAyC;AACzC;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA,8BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,sEAAqE,mDAAmD;AACxH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,kCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA,sBAAqB;;AAErB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;;AAEA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD,mBAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yEAAwE,wBAAwB;AAChG;AACA,sCAAqC;AACrC,kCAAiC;AACjC;AACA,kCAAiC;;AAEjC,8BAA6B;AAC7B;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD;;AAErD;AACA;;AAEA;AACA;AACA;;AAEA,4CAA2C,uBAAuB;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C,oCAAmC,OAAO;AAC1C,qCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,0BAAyB;AACzB;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,8BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,sBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC,G","file":"0.dda3bc49872534d9db36.hot-update.js","sourcesContent":["(function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['angular', 'objectpath', 'tv4'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('angular'), require('objectpath'), require('tv4'));\n    } else {\n        root.schemaForm = factory(root.angular, root.objectpath, root.tv4);\n    }\n}(this, function(angular, objectpath, tv4) {\n    // Deps is sort of a problem for us, maybe in the future we will ask the user to depend\n    // on modules for add-ons\n\n    var deps = [];\n    try {\n        //This throws an expection if module does not exist.\n        angular.module('ngSanitize');\n        deps.push('ngSanitize');\n    } catch (e) {}\n\n    try {\n        //This throws an expection if module does not exist.\n        angular.module('ui.sortable');\n        deps.push('ui.sortable');\n    } catch (e) {}\n\n    try {\n        //This throws an expection if module does not exist.\n        angular.module('angularSpectrumColorpicker');\n        deps.push('angularSpectrumColorpicker');\n    } catch (e) {}\n\n    var schemaForm = angular.module('schemaForm', deps);\n\n    angular.module('schemaForm').provider('sfPath', [function() {\n\n        // When building with browserify ObjectPath is available as `objectpath` but othwerwise\n        // it's called `ObjectPath`.\n        var ObjectPath = window.ObjectPath || objectpath;\n\n        var sfPath = { parse: ObjectPath.parse };\n\n        // if we're on Angular 1.2.x, we need to continue using dot notation\n        if (angular.version.major === 1 && angular.version.minor < 3) {\n            sfPath.stringify = function(arr) {\n                return Array.isArray(arr) ? arr.join('.') : arr.toString();\n            };\n        } else {\n            sfPath.stringify = ObjectPath.stringify;\n        }\n\n        // We want this to use whichever stringify method is defined above,\n        // so we have to copy the code here.\n        sfPath.normalize = function(data, quote) {\n            return sfPath.stringify(Array.isArray(data) ? data : sfPath.parse(data), quote);\n        };\n\n        // expose the methods in sfPathProvider\n        this.parse = sfPath.parse;\n        this.stringify = sfPath.stringify;\n        this.normalize = sfPath.normalize;\n\n        this.$get = function() {\n            return sfPath;\n        };\n    }]);\n\n    /**\n     * @ngdoc service\n     * @name sfSelect\n     * @kind function\n     *\n     */\n    angular.module('schemaForm').factory('sfSelect', ['sfPath', function(sfPath) {\n        var numRe = /^\\d+$/;\n\n        /**\n         * @description\n         * Utility method to access deep properties without\n         * throwing errors when things are not defined.\n         * Can also set a value in a deep structure, creating objects when missing\n         * ex.\n         * var foo = Select('address.contact.name',obj)\n         * Select('address.contact.name',obj,'Leeroy')\n         *\n         * @param {string} projection A dot path to the property you want to get/set\n         * @param {object} obj   (optional) The object to project on, defaults to 'this'\n         * @param {Any}    valueToSet (opional)  The value to set, if parts of the path of\n         *                 the projection is missing empty objects will be created.\n         * @returns {Any|undefined} returns the value at the end of the projection path\n         *                          or undefined if there is none.\n         */\n        return function(projection, obj, valueToSet) {\n            if (!obj) {\n                obj = this;\n            }\n            //Support [] array syntax\n            var parts = typeof projection === 'string' ? sfPath.parse(projection) : projection;\n\n            if (typeof valueToSet !== 'undefined' && parts.length === 1) {\n                //special case, just setting one variable\n                obj[parts[0]] = valueToSet;\n                return obj;\n            }\n\n            if (typeof valueToSet !== 'undefined' &&\n                typeof obj[parts[0]] === 'undefined') {\n                // We need to look ahead to check if array is appropriate\n                obj[parts[0]] = parts.length > 2 && numRe.test(parts[1]) ? [] : {};\n            }\n\n            var value = obj[parts[0]];\n            for (var i = 1; i < parts.length; i++) {\n                // Special case: We allow JSON Form syntax for arrays using empty brackets\n                // These will of course not work here so we exit if they are found.\n                if (parts[i] === '') {\n                    return undefined;\n                }\n                if (typeof valueToSet !== 'undefined') {\n                    if (i === parts.length - 1) {\n                        //last step. Let's set the value\n                        value[parts[i]] = valueToSet;\n                        return valueToSet;\n                    } else {\n                        // Make sure to create new objects on the way if they are not there.\n                        // We need to look ahead to check if array is appropriate\n                        var tmp = value[parts[i]];\n                        if (typeof tmp === 'undefined' || tmp === null) {\n                            tmp = numRe.test(parts[i + 1]) ? [] : {};\n                            value[parts[i]] = tmp;\n                        }\n                        value = tmp;\n                    }\n                } else if (value) {\n                    //Just get nex value.\n                    value = value[parts[i]];\n                }\n            }\n            return value;\n        };\n    }]);\n\n\n    // FIXME: type template (using custom builder)\n    angular.module('schemaForm').provider('sfBuilder', ['sfPathProvider', function(sfPathProvider) {\n\n        var SNAKE_CASE_REGEXP = /[A-Z]/g;\n        var snakeCase = function(name, separator) {\n            separator = separator || '_';\n            return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n                return (pos ? separator : '') + letter.toLowerCase();\n            });\n        };\n        var formId = 0;\n\n        var builders = {\n            sfField: function(args) {\n                args.fieldFrag.firstChild.setAttribute('sf-field', formId);\n\n                // We use a lookup table for easy access to our form.\n                args.lookup['f' + formId] = args.form;\n                formId++;\n            },\n            ngModel: function(args) {\n                if (!args.form.key) {\n                    return;\n                }\n                var key = args.form.key;\n\n                // Redact part of the key, used in arrays\n                // KISS keyRedaction is a number.\n                if (args.state.keyRedaction) {\n                    key = key.slice(args.state.keyRedaction);\n                }\n\n                // Stringify key.\n                var modelValue;\n                if (!args.state.modelValue) {\n                    var strKey = sfPathProvider.stringify(key).replace(/\"/g, '&quot;');\n                    modelValue = (args.state.modelName || 'model');\n\n                    if (strKey) { // Sometimes, like with arrays directly in arrays strKey is nothing.\n                        modelValue += (strKey[0] !== '[' ? '.' : '') + strKey;\n                    }\n                } else {\n                    // Another builder, i.e. array has overriden the modelValue\n                    modelValue = args.state.modelValue;\n                }\n\n                // Find all sf-field-value attributes.\n                // No value means a add a ng-model.\n                // sf-field-value=\"replaceAll\", loop over attributes and replace $$value$$ in each.\n                // sf-field-value=\"attrName\", replace or set value of that attribute.\n                var nodes = args.fieldFrag.querySelectorAll('[sf-field-model]');\n                for (var i = 0; i < nodes.length; i++) {\n                    var n = nodes[i];\n                    var conf = n.getAttribute('sf-field-model');\n                    if (!conf || conf === '') {\n                        n.setAttribute('ng-model', modelValue);\n                    } else if (conf === 'replaceAll') {\n                        var attributes = n.attributes;\n                        for (var j = 0; j < attributes.length; j++) {\n                            if (attributes[j].value && attributes[j].value.indexOf('$$value') !== -1) {\n                                attributes[j].value = attributes[j].value.replace(/\\$\\$value\\$\\$/g, modelValue);\n                            }\n                        }\n                    } else {\n                        var val = n.getAttribute(conf);\n                        if (val && val.indexOf('$$value$$')) {\n                            n.setAttribute(conf, val.replace(/\\$\\$value\\$\\$/g, modelValue));\n                        } else {\n                            n.setAttribute(conf, modelValue);\n                        }\n                    }\n                }\n            },\n            simpleTransclusion: function(args) {\n                var children = args.build(args.form.items, args.path + '.items', args.state);\n                args.fieldFrag.firstChild.appendChild(children);\n            },\n\n            // Patch on ngModelOptions, since it doesn't like waiting for its value.\n            ngModelOptions: function(args) {\n                if (args.form.ngModelOptions && Object.keys(args.form.ngModelOptions).length > 0) {\n                    args.fieldFrag.firstChild.setAttribute('ng-model-options', JSON.stringify(args.form.ngModelOptions));\n                }\n            },\n            transclusion: function(args) {\n                var transclusions = args.fieldFrag.querySelectorAll('[sf-field-transclude]');\n\n                if (transclusions.length) {\n                    for (var i = 0; i < transclusions.length; i++) {\n                        var n = transclusions[i];\n\n                        // The sf-transclude attribute is not a directive,\n                        // but has the name of what we're supposed to\n                        // traverse. Default to `items`\n                        var sub = n.getAttribute('sf-field-transclude') || 'items';\n                        var items = args.form[sub];\n\n                        if (items) {\n                            var childFrag = args.build(items, args.path + '.' + sub, args.state);\n                            n.appendChild(childFrag);\n                        }\n                    }\n                }\n            },\n            condition: function(args) {\n                // Do we have a condition? Then we slap on an ng-if on all children,\n                // but be nice to existing ng-if.\n                if (args.form.condition) {\n                    var evalExpr = 'evalExpr(' + args.path +\n                        '.condition, { model: model, \"arrayIndex\": $index})';\n                    if (args.form.key) {\n                        var strKey = sfPathProvider.stringify(args.form.key);\n                        evalExpr = 'evalExpr(' + args.path + '.condition,{ model: model, \"arrayIndex\": $index, ' +\n                            '\"modelValue\": model' + (strKey[0] === '[' ? '' : '.') + strKey + '})';\n                    }\n\n                    var children = args.fieldFrag.children || args.fieldFrag.childNodes;\n                    for (var i = 0; i < children.length; i++) {\n                        var child = children[i];\n                        var ngIf = child.getAttribute('ng-if');\n                        child.setAttribute(\n                            'ng-if',\n                            ngIf ?\n                            '(' + ngIf +\n                            ') || (' + evalExpr + ')' : evalExpr\n                        );\n                    }\n                }\n            },\n            array: function(args) {\n                var items = args.fieldFrag.querySelector('[schema-form-array-items]');\n                if (items) {\n                    state = angular.copy(args.state);\n                    state.keyRedaction = 0;\n                    state.keyRedaction += args.form.key.length + 1;\n\n                    // Special case, an array with just one item in it that is not an object.\n                    // So then we just override the modelValue\n                    if (args.form.schema && args.form.schema.items &&\n                        args.form.schema.items.type &&\n                        args.form.schema.items.type.indexOf('object') === -1 &&\n                        args.form.schema.items.type.indexOf('array') === -1) {\n                        var strKey = sfPathProvider.stringify(args.form.key).replace(/\"/g, '&quot;') + '[$index]';\n                        state.modelValue = 'modelArray[$index]';\n                    } else {\n                        state.modelName = 'item';\n                    }\n\n                    // Flag to the builder that where in an array.\n                    // This is needed for compatabiliy if a \"old\" add-on is used that\n                    // hasn't been transitioned to the new builder.\n                    state.arrayCompatFlag = true;\n\n                    var childFrag = args.build(args.form.items, args.path + '.items', state);\n                    items.appendChild(childFrag);\n                }\n            }\n        };\n        this.builders = builders;\n        var stdBuilders = [\n            builders.sfField,\n            builders.ngModel,\n            builders.ngModelOptions,\n            builders.condition\n        ];\n        this.stdBuilders = stdBuilders;\n\n        this.$get = ['$templateCache', 'schemaFormDecorators', 'sfPath', function($templateCache, schemaFormDecorators, sfPath) {\n\n\n            var checkForSlot = function(form, slots) {\n                // Finally append this field to the frag.\n                // Check for slots\n                if (form.key) {\n                    var slot = slots[sfPath.stringify(form.key)];\n                    if (slot) {\n                        while (slot.firstChild) {\n                            slot.removeChild(slot.firstChild);\n                        }\n                        return slot;\n                    }\n                }\n            };\n\n            var build = function(items, decorator, templateFn, slots, path, state, lookup) {\n                state = state || {};\n                lookup = lookup || Object.create(null);\n                path = path || 'schemaForm.form';\n                var container = document.createDocumentFragment();\n                items.reduce(function(frag, f, index) {\n\n                    // Sanity check.\n                    if (!f.type) {\n                        return frag;\n                    }\n\n                    var field = decorator[f.type] || decorator['default'];\n                    if (!field.replace) {\n                        // Backwards compatability build\n                        var n = document.createElement(snakeCase(decorator.__name, '-'));\n                        if (state.arrayCompatFlag) {\n                            n.setAttribute('form', 'copyWithIndex($index)');\n                        } else {\n                            n.setAttribute('form', path + '[' + index + ']');\n                        }\n\n                        (checkForSlot(f, slots) || frag).appendChild(n);\n\n                    } else {\n                        var tmpl;\n\n                        // Reset arrayCompatFlag, it's only valid for direct children of the array.\n                        state.arrayCompatFlag = false;\n\n                        // TODO: Create a couple fo testcases, small and large and\n                        //       measure optmization. A good start is probably a cache of DOM nodes for a particular\n                        //       template that can be cloned instead of using innerHTML\n                        var div = document.createElement('div');\n                        var template = templateFn(f, field) || templateFn(f, decorator['default']);\n                        div.innerHTML = template;\n\n                        // Move node to a document fragment, we don't want the div.\n                        tmpl = document.createDocumentFragment();\n                        while (div.childNodes.length > 0) {\n                            tmpl.appendChild(div.childNodes[0]);\n                        }\n\n                        // Possible builder, often a noop\n                        var args = {\n                            fieldFrag: tmpl,\n                            form: f,\n                            lookup: lookup,\n                            state: state,\n                            path: path + '[' + index + ']',\n\n                            // Recursive build fn\n                            build: function(items, path, state) {\n                                return build(items, decorator, templateFn, slots, path, state, lookup);\n                            },\n\n                        };\n\n                        // Let the form definiton override builders if it wants to.\n                        var builderFn = f.builder || field.builder;\n\n                        // Builders are either a function or a list of functions.\n                        if (typeof builderFn === 'function') {\n                            builderFn(args);\n                        } else {\n                            builderFn.forEach(function(fn) {\n                                fn(args);\n                            });\n                        }\n\n                        // Append\n                        (checkForSlot(f, slots) || frag).appendChild(tmpl);\n                    }\n                    return frag;\n                }, container);\n\n                return container;\n            };\n\n            return {\n                /**\n                 * Builds a form from a canonical form definition\n                 */\n                build: function(form, decorator, slots, lookup) {\n                    return build(form, decorator, function(form, field) {\n                        if (form.type === 'template') {\n                            return form.template;\n                        }\n                        return $templateCache.get(field.template);\n                    }, slots, undefined, undefined, lookup);\n\n                },\n                builder: builders,\n                stdBuilders: stdBuilders,\n                internalBuild: build\n            };\n        }];\n\n    }]);\n\n    angular.module('schemaForm').provider('schemaFormDecorators', ['$compileProvider', 'sfPathProvider', function($compileProvider, sfPathProvider) {\n        var defaultDecorator = '';\n        var decorators = {};\n\n        // Map template after decorator and type.\n        var templateUrl = function(name, form) {\n            //schemaDecorator is alias for whatever is set as default\n            if (name === 'sfDecorator') {\n                name = defaultDecorator;\n            }\n\n            var decorator = decorators[name];\n            if (decorator[form.type]) {\n                return decorator[form.type].template;\n            }\n\n            //try default\n            return decorator['default'].template;\n        };\n\n        /**************************************************\n         * DEPRECATED                                     *\n         * The new builder and sf-field is preferred, but *\n         * we keep this in during a transitional period   *\n         * so that add-ons that don't use the new builder *\n         * works.                                         *\n         **************************************************/\n        //TODO: Move to a compatability extra script.\n        var createDirective = function(name) {\n            $compileProvider.directive(name, ['$parse', '$compile', '$http', '$templateCache', '$interpolate', '$q', 'sfErrorMessage',\n                'sfPath', 'sfSelect',\n                function($parse, $compile, $http, $templateCache, $interpolate, $q, sfErrorMessage,\n                    sfPath, sfSelect) {\n\n                    return {\n                        restrict: 'AE',\n                        replace: false,\n                        transclude: false,\n                        scope: true,\n                        require: '?^sfSchema',\n                        link: function(scope, element, attrs, sfSchema) {\n\n                            //The ngModelController is used in some templates and\n                            //is needed for error messages,\n                            scope.$on('schemaFormPropagateNgModelController', function(event, ngModel) {\n                                event.stopPropagation();\n                                event.preventDefault();\n                                scope.ngModel = ngModel;\n                            });\n\n                            //Keep error prone logic from the template\n                            scope.showTitle = function() {\n                                return scope.form && scope.form.notitle !== true && scope.form.title;\n                            };\n\n                            scope.listToCheckboxValues = function(list) {\n                                var values = {};\n                                angular.forEach(list, function(v) {\n                                    values[v] = true;\n                                });\n                                return values;\n                            };\n\n                            scope.checkboxValuesToList = function(values) {\n                                var lst = [];\n                                angular.forEach(values, function(v, k) {\n                                    if (v) {\n                                        lst.push(k);\n                                    }\n                                });\n                                return lst;\n                            };\n\n                            scope.buttonClick = function($event, form) {\n                                if (angular.isFunction(form.onClick)) {\n                                    form.onClick($event, form);\n                                } else if (angular.isString(form.onClick)) {\n                                    if (sfSchema) {\n                                        //evaluating in scope outside of sfSchemas isolated scope\n                                        sfSchema.evalInParentScope(form.onClick, {\n                                            '$event': $event,\n                                            form: form\n                                        });\n                                    } else {\n                                        scope.$eval(form.onClick, { '$event': $event, form: form });\n                                    }\n                                }\n                            };\n\n                            /**\n                             * Evaluate an expression, i.e. scope.$eval\n                             * but do it in sfSchemas parent scope sf-schema directive is used\n                             * @param {string} expression\n                             * @param {Object} locals (optional)\n                             * @return {Any} the result of the expression\n                             */\n                            scope.evalExpr = function(expression, locals) {\n                                if (sfSchema) {\n                                    //evaluating in scope outside of sfSchemas isolated scope\n                                    return sfSchema.evalInParentScope(expression, locals);\n                                }\n\n                                return scope.$eval(expression, locals);\n                            };\n\n                            /**\n                             * Evaluate an expression, i.e. scope.$eval\n                             * in this decorators scope\n                             * @param {string} expression\n                             * @param {Object} locals (optional)\n                             * @return {Any} the result of the expression\n                             */\n                            scope.evalInScope = function(expression, locals) {\n                                if (expression) {\n                                    return scope.$eval(expression, locals);\n                                }\n                            };\n\n                            /**\n                             * Interpolate the expression.\n                             * Similar to `evalExpr()` and `evalInScope()`\n                             * but will not fail if the expression is\n                             * text that contains spaces.\n                             *\n                             * Use the Angular `{{ interpolation }}`\n                             * braces to access properties on `locals`.\n                             *\n                             * @param  {string} content The string to interpolate.\n                             * @param  {Object} locals (optional) Properties that may be accessed in the\n                             *                         `expression` string.\n                             * @return {Any} The result of the expression or `undefined`.\n                             */\n                            scope.interp = function(expression, locals) {\n                                return (expression && $interpolate(expression)(locals));\n                            };\n\n                            //This works since we ot the ngModel from the array or the schema-validate directive.\n                            scope.hasSuccess = function() {\n                                if (!scope.ngModel) {\n                                    return false;\n                                }\n                                return scope.ngModel.$valid &&\n                                    (!scope.ngModel.$pristine || !scope.ngModel.$isEmpty(scope.ngModel.$modelValue));\n                            };\n\n                            scope.hasError = function() {\n                                if (!scope.ngModel) {\n                                    return false;\n                                }\n                                return scope.ngModel.$invalid && !scope.ngModel.$pristine;\n                            };\n\n                            /**\n                             * DEPRECATED: use sf-messages instead.\n                             * Error message handler\n                             * An error can either be a schema validation message or a angular js validtion\n                             * error (i.e. required)\n                             */\n                            scope.errorMessage = function(schemaError) {\n                                return sfErrorMessage.interpolate(\n                                    (schemaError && schemaError.code + '') || 'default',\n                                    (scope.ngModel && scope.ngModel.$modelValue) || '',\n                                    (scope.ngModel && scope.ngModel.$viewValue) || '',\n                                    scope.form,\n                                    scope.options && scope.options.validationMessage\n                                );\n                            };\n\n                            // Rebind our part of the form to the scope.\n                            var once = scope.$watch(attrs.form, function(form) {\n                                if (form) {\n                                    // Workaround for 'updateOn' error from ngModelOptions\n                                    // see https://github.com/Textalk/angular-schema-form/issues/255\n                                    // and https://github.com/Textalk/angular-schema-form/issues/206\n                                    form.ngModelOptions = form.ngModelOptions || {};\n                                    scope.form = form;\n\n                                    //ok let's replace that template!\n                                    //We do this manually since we need to bind ng-model properly and also\n                                    //for fieldsets to recurse properly.\n                                    var templatePromise;\n\n                                    // type: \"template\" is a special case. It can contain a template inline or an url.\n                                    // otherwise we find out the url to the template and load them.\n                                    if (form.type === 'template' && form.template) {\n                                        templatePromise = $q.when(form.template);\n                                    } else {\n                                        var url = form.type === 'template' ? form.templateUrl : templateUrl(name, form);\n                                        templatePromise = $http.get(url, { cache: $templateCache }).then(function(res) {\n                                            return res.data;\n                                        });\n                                    }\n\n                                    templatePromise.then(function(template) {\n                                        if (form.key) {\n                                            var key = form.key ?\n                                                sfPathProvider.stringify(form.key).replace(/\"/g, '&quot;') : '';\n                                            template = template.replace(\n                                                /\\$\\$value\\$\\$/g,\n                                                'model' + (key[0] !== '[' ? '.' : '') + key\n                                            );\n                                        }\n                                        element.html(template);\n\n                                        // Do we have a condition? Then we slap on an ng-if on all children,\n                                        // but be nice to existing ng-if.\n                                        if (form.condition) {\n\n                                            var evalExpr = 'evalExpr(form.condition,{ model: model, \"arrayIndex\": arrayIndex})';\n                                            if (form.key) {\n                                                evalExpr = 'evalExpr(form.condition,{ model: model, \"arrayIndex\": arrayIndex, \"modelValue\": model' + sfPath.stringify(form.key) + '})';\n                                            }\n\n                                            angular.forEach(element.children(), function(child) {\n                                                var ngIf = child.getAttribute('ng-if');\n                                                child.setAttribute(\n                                                    'ng-if',\n                                                    ngIf ?\n                                                    '(' + ngIf +\n                                                    ') || (' + evalExpr + ')' : evalExpr\n                                                );\n                                            });\n                                        }\n                                        $compile(element.contents())(scope);\n                                    });\n\n                                    // Where there is a key there is probably a ngModel\n                                    if (form.key) {\n                                        // It looks better with dot notation.\n                                        scope.$on(\n                                            'schemaForm.error.' + form.key.join('.'),\n                                            function(event, error, validationMessage, validity) {\n                                                if (validationMessage === true || validationMessage === false) {\n                                                    validity = validationMessage;\n                                                    validationMessage = undefined;\n                                                }\n\n                                                if (scope.ngModel && error) {\n                                                    if (scope.ngModel.$setDirty) {\n                                                        scope.ngModel.$setDirty();\n                                                    } else {\n                                                        // FIXME: Check that this actually works on 1.2\n                                                        scope.ngModel.$dirty = true;\n                                                        scope.ngModel.$pristine = false;\n                                                    }\n\n                                                    // Set the new validation message if one is supplied\n                                                    // Does not work when validationMessage is just a string.\n                                                    if (validationMessage) {\n                                                        if (!form.validationMessage) {\n                                                            form.validationMessage = {};\n                                                        }\n                                                        form.validationMessage[error] = validationMessage;\n                                                    }\n\n                                                    scope.ngModel.$setValidity(error, validity === true);\n\n                                                    if (validity === true) {\n                                                        // Setting or removing a validity can change the field to believe its valid\n                                                        // but its not. So lets trigger its validation as well.\n                                                        scope.$broadcast('schemaFormValidate');\n                                                    }\n                                                }\n                                            });\n\n                                        // Clean up the model when the corresponding form field is $destroy-ed.\n                                        // Default behavior can be supplied as a globalOption, and behavior can be overridden in the form definition.\n                                        scope.$on('$destroy', function() {\n                                            // If the entire schema form is destroyed we don't touch the model\n                                            if (!scope.externalDestructionInProgress) {\n                                                var destroyStrategy = form.destroyStrategy ||\n                                                    (scope.options && scope.options.destroyStrategy) || 'remove';\n                                                // No key no model, and we might have strategy 'retain'\n                                                if (form.key && destroyStrategy !== 'retain') {\n\n                                                    // Get the object that has the property we wan't to clear.\n                                                    var obj = scope.model;\n                                                    if (form.key.length > 1) {\n                                                        obj = sfSelect(form.key.slice(0, form.key.length - 1), obj);\n                                                    }\n\n                                                    // We can get undefined here if the form hasn't been filled out entirely\n                                                    if (obj === undefined) {\n                                                        return;\n                                                    }\n\n                                                    // Type can also be a list in JSON Schema\n                                                    var type = (form.schema && form.schema.type) || '';\n\n                                                    // Empty means '',{} and [] for appropriate types and undefined for the rest\n                                                    if (destroyStrategy === 'empty' && type.indexOf('string') !== -1) {\n                                                        obj[form.key.slice(-1)] = '';\n                                                    } else if (destroyStrategy === 'empty' && type.indexOf('object') !== -1) {\n                                                        obj[form.key.slice(-1)] = {};\n                                                    } else if (destroyStrategy === 'empty' && type.indexOf('array') !== -1) {\n                                                        obj[form.key.slice(-1)] = [];\n                                                    } else if (destroyStrategy === 'null') {\n                                                        obj[form.key.slice(-1)] = null;\n                                                    } else {\n                                                        delete obj[form.key.slice(-1)];\n                                                    }\n                                                }\n                                            }\n                                        });\n                                    }\n\n                                    once();\n                                }\n                            });\n                        }\n                    };\n                }\n            ]);\n        };\n\n        var createManualDirective = function(type, templateUrl, transclude) {\n            transclude = angular.isDefined(transclude) ? transclude : false;\n            $compileProvider.directive('sf' + angular.uppercase(type[0]) + type.substr(1), function() {\n                return {\n                    restrict: 'EAC',\n                    scope: true,\n                    replace: true,\n                    transclude: transclude,\n                    template: '<sf-decorator form=\"form\"></sf-decorator>',\n                    link: function(scope, element, attrs) {\n                        var watchThis = {\n                            'items': 'c',\n                            'titleMap': 'c',\n                            'schema': 'c'\n                        };\n                        var form = { type: type };\n                        var once = true;\n                        angular.forEach(attrs, function(value, name) {\n                            if (name[0] !== '$' && name.indexOf('ng') !== 0 && name !== 'sfField') {\n\n                                var updateForm = function(val) {\n                                    if (angular.isDefined(val) && val !== form[name]) {\n                                        form[name] = val;\n\n                                        //when we have type, and if specified key we apply it on scope.\n                                        if (once && form.type && (form.key || angular.isUndefined(attrs.key))) {\n                                            scope.form = form;\n                                            once = false;\n                                        }\n                                    }\n                                };\n\n                                if (name === 'model') {\n                                    //\"model\" is bound to scope under the name \"model\" since this is what the decorators\n                                    //know and love.\n                                    scope.$watch(value, function(val) {\n                                        if (val && scope.model !== val) {\n                                            scope.model = val;\n                                        }\n                                    });\n                                } else if (watchThis[name] === 'c') {\n                                    //watch collection\n                                    scope.$watchCollection(value, updateForm);\n                                } else {\n                                    //$observe\n                                    attrs.$observe(name, updateForm);\n                                }\n                            }\n                        });\n                    }\n                };\n            });\n        };\n\n        /**\n         * DEPRECATED: use defineDecorator instead.\n         * Create a decorator directive and its sibling \"manual\" use decorators.\n         * The directive can be used to create form fields or other form entities.\n         * It can be used in conjunction with <schema-form> directive in which case the decorator is\n         * given it's configuration via a the \"form\" attribute.\n         *\n         * ex. Basic usage\n         *   <sf-decorator form=\"myform\"></sf-decorator>\n         **\n         * @param {string} name directive name (CamelCased)\n         * @param {Object} templates, an object that maps \"type\" => \"templateUrl\"\n         */\n        this.createDecorator = function(name, templates) {\n            //console.warn('schemaFormDecorators.createDecorator is DEPRECATED, use defineDecorator instead.');\n            decorators[name] = { '__name': name };\n\n            angular.forEach(templates, function(url, type) {\n                decorators[name][type] = { template: url, replace: false, builder: [] };\n            });\n\n            if (!decorators[defaultDecorator]) {\n                defaultDecorator = name;\n            }\n            createDirective(name);\n        };\n\n\n        /**\n         * Define a decorator. A decorator is a set of form types with templates and builder functions\n         * that help set up the form.\n         *\n         * @param {string} name directive name (CamelCased)\n         * @param {Object} fields, an object that maps \"type\" => `{ template, builder, replace}`.\n         attributes `builder` and `replace` are optional, and replace defaults to true.\n\n         `template` should be the key of the template to load and it should be pre-loaded\n         in `$templateCache`.\n\n         `builder` can be a function or an array of functions. They will be called in\n         the order they are supplied.\n\n         `replace` (DEPRECATED) is for backwards compatability. If false the builder\n         will use the \"old\" way of building that form field using a <sf-decorator>\n         directive.\n         */\n        this.defineDecorator = function(name, fields) {\n            decorators[name] = { '__name': name }; // TODO: this feels like a hack, come up with a better way.\n\n            angular.forEach(fields, function(field, type) {\n                field.builder = field.builder || [];\n                field.replace = angular.isDefined(field.replace) ? field.replace : true;\n                decorators[name][type] = field;\n            });\n\n            if (!decorators[defaultDecorator]) {\n                defaultDecorator = name;\n            }\n            createDirective(name);\n        };\n\n        /**\n         * DEPRECATED\n         * Creates a directive of a decorator\n         * Usable when you want to use the decorators without using <schema-form> directive.\n         * Specifically when you need to reuse styling.\n         *\n         * ex. createDirective('text','...')\n         *  <sf-text title=\"foobar\" model=\"person\" key=\"name\" schema=\"schema\"></sf-text>\n         *\n         * @param {string}  type The type of the directive, resulting directive will have sf- prefixed\n         * @param {string}  templateUrl\n         * @param {boolean} transclude (optional) sets transclude option of directive, defaults to false.\n         */\n        this.createDirective = createManualDirective;\n\n        /**\n         * DEPRECATED\n         * Same as createDirective, but takes an object where key is 'type' and value is 'templateUrl'\n         * Useful for batching.\n         * @param {Object} templates\n         */\n        this.createDirectives = function(templates) {\n            angular.forEach(templates, function(url, type) {\n                createManualDirective(type, url);\n            });\n        };\n\n        /**\n         * Getter for decorator settings\n         * @param {string} name (optional) defaults to defaultDecorator\n         * @return {Object} rules and templates { rules: [],templates: {}}\n         */\n        this.decorator = function(name) {\n            name = name || defaultDecorator;\n            return decorators[name];\n        };\n\n\n        /**\n         * DEPRECATED use defineAddOn() instead.\n         * Adds a mapping to an existing decorator.\n         * @param {String} name Decorator name\n         * @param {String} type Form type for the mapping\n         * @param {String} url  The template url\n         * @param {Function} builder (optional) builder function\n         * @param {boolean} replace (optional) defaults to false. Replace decorator directive with template.\n         */\n        this.addMapping = function(name, type, url, builder, replace) {\n            if (decorators[name]) {\n                decorators[name][type] = {\n                    template: url,\n                    builder: builder,\n                    replace: !!replace\n                };\n            }\n        };\n\n        /**\n         * Adds an add-on to an existing decorator.\n         * @param {String} name Decorator name\n         * @param {String} type Form type for the mapping\n         * @param {String} url  The template url\n         * @param {Function|Array} builder (optional) builder function(s),\n         */\n        this.defineAddOn = function(name, type, url, builder) {\n            if (decorators[name]) {\n                decorators[name][type] = {\n                    template: url,\n                    builder: builder,\n                    replace: true\n                };\n            }\n        };\n\n\n        //Service is just a getter for directive templates and rules\n        this.$get = function() {\n            return {\n                decorator: function(name) {\n                    return decorators[name] || decorators[defaultDecorator];\n                },\n                defaultDecorator: defaultDecorator\n            };\n        };\n\n        //Create a default directive\n        createDirective('sfDecorator');\n\n    }]);\n\n    angular.module('schemaForm').provider('sfErrorMessage', function() {\n\n        // The codes are tv4 error codes.\n        // Not all of these can actually happen in a field, but for\n        // we never know when one might pop up so it's best to cover them all.\n\n        // TODO: Humanize these.\n        var defaultMessages = {\n            'default': 'Field does not validate',\n            0: 'Invalid type, expected {{schema.type}}',\n            1: 'No enum match for: {{viewValue}}',\n            10: 'Data does not match any schemas from \"anyOf\"',\n            11: 'Data does not match any schemas from \"oneOf\"',\n            12: 'Data is valid against more than one schema from \"oneOf\"',\n            13: 'Data matches schema from \"not\"',\n            // Numeric errors\n            100: 'Value is not a multiple of {{schema.multipleOf}}',\n            101: '{{viewValue}} is less than the allowed minimum of {{schema.minimum}}',\n            102: '{{viewValue}} is equal to the exclusive minimum {{schema.minimum}}',\n            103: '{{viewValue}} is greater than the allowed maximum of {{schema.maximum}}',\n            104: '{{viewValue}} is equal to the exclusive maximum {{schema.maximum}}',\n            105: 'Value is not a valid number',\n            // String errors\n            200: 'String is too short ({{viewValue.length}} chars), minimum {{schema.minLength}}',\n            201: 'String is too long ({{viewValue.length}} chars), maximum {{schema.maxLength}}',\n            202: 'String does not match pattern: {{schema.pattern}}',\n            // Object errors\n            300: 'Too few properties defined, minimum {{schema.minProperties}}',\n            301: 'Too many properties defined, maximum {{schema.maxProperties}}',\n            302: 'Required',\n            303: 'Additional properties not allowed',\n            304: 'Dependency failed - key must exist',\n            // Array errors\n            400: 'Array is too short ({{value.length}}), minimum {{schema.minItems}}',\n            401: 'Array is too long ({{value.length}}), maximum {{schema.maxItems}}',\n            402: 'Array items are not unique',\n            403: 'Additional items not allowed',\n            // Format errors\n            500: 'Format validation failed',\n            501: 'Keyword failed: \"{{title}}\"',\n            // Schema structure\n            600: 'Circular $refs',\n            // Non-standard validation options\n            1000: 'Unknown property (not in schema)'\n        };\n\n        // In some cases we get hit with an angular validation error\n        defaultMessages.number = defaultMessages[105];\n        defaultMessages.required = defaultMessages[302];\n        defaultMessages.min = defaultMessages[101];\n        defaultMessages.max = defaultMessages[103];\n        defaultMessages.maxlength = defaultMessages[201];\n        defaultMessages.minlength = defaultMessages[200];\n        defaultMessages.pattern = defaultMessages[202];\n\n        this.setDefaultMessages = function(messages) {\n            defaultMessages = messages;\n        };\n\n        this.getDefaultMessages = function() {\n            return defaultMessages;\n        };\n\n        this.setDefaultMessage = function(error, msg) {\n            defaultMessages[error] = msg;\n        };\n\n        this.$get = ['$interpolate', function($interpolate) {\n\n            var service = {};\n            service.defaultMessages = defaultMessages;\n\n            /**\n             * Interpolate and return proper error for an eror code.\n             * Validation message on form trumps global error messages.\n             * and if the message is a function instead of a string that function will be called instead.\n             * @param {string} error the error code, i.e. tv4-xxx for tv4 errors, otherwise it's whats on\n             *                       ngModel.$error for custom errors.\n             * @param {Any} value the actual model value.\n             * @param {Any} viewValue the viewValue\n             * @param {Object} form a form definition object for this field\n             * @param  {Object} global the global validation messages object (even though its called global\n             *                         its actually just shared in one instance of sf-schema)\n             * @return {string} The error message.\n             */\n            service.interpolate = function(error, value, viewValue, form, global) {\n                global = global || {};\n                var validationMessage = form.validationMessage || {};\n\n                // Drop tv4 prefix so only the code is left.\n                if (error.indexOf('tv4-') === 0) {\n                    error = error.substring(4);\n                }\n\n                // First find apropriate message or function\n                var message = validationMessage['default'] || global['default'] || '';\n\n                [validationMessage, global, defaultMessages].some(function(val) {\n                    if (angular.isString(val) || angular.isFunction(val)) {\n                        message = val;\n                        return true;\n                    }\n                    if (val && val[error]) {\n                        message = val[error];\n                        return true;\n                    }\n                });\n\n                var context = {\n                    error: error,\n                    value: value,\n                    viewValue: viewValue,\n                    form: form,\n                    schema: form.schema,\n                    title: form.title || (form.schema && form.schema.title)\n                };\n                if (angular.isFunction(message)) {\n                    return message(context);\n                } else {\n                    return $interpolate(message)(context);\n                }\n            };\n\n            return service;\n        }];\n\n    });\n\n    /**\n     * Schema form service.\n     * This service is not that useful outside of schema form directive\n     * but makes the code more testable.\n     */\n    angular.module('schemaForm').provider('schemaForm', ['sfPathProvider', function(sfPathProvider) {\n        var stripNullType = function(type) {\n            if (Array.isArray(type) && type.length == 2) {\n                if (type[0] === 'null')\n                    return type[1];\n                if (type[1] === 'null')\n                    return type[0];\n            }\n            return type;\n        }\n\n        //Creates an default titleMap list from an enum, i.e. a list of strings.\n        var enumToTitleMap = function(enm) {\n            var titleMap = []; //canonical titleMap format is a list.\n            enm.forEach(function(name) {\n                titleMap.push({ name: name, value: name });\n            });\n            return titleMap;\n        };\n\n        // Takes a titleMap in either object or list format and returns one in\n        // in the list format.\n        var canonicalTitleMap = function(titleMap, originalEnum) {\n            if (!angular.isArray(titleMap)) {\n                var canonical = [];\n                if (originalEnum) {\n                    angular.forEach(originalEnum, function(value, index) {\n                        canonical.push({ name: titleMap[value], value: value });\n                    });\n                } else {\n                    angular.forEach(titleMap, function(name, value) {\n                        canonical.push({ name: name, value: value });\n                    });\n                }\n                return canonical;\n            }\n            return titleMap;\n        };\n\n        var defaultFormDefinition = function(name, schema, options) {\n            var rules = defaults[stripNullType(schema.type)];\n            if (rules) {\n                var def;\n                for (var i = 0; i < rules.length; i++) {\n                    def = rules[i](name, schema, options);\n\n                    //first handler in list that actually returns something is our handler!\n                    if (def) {\n\n                        // Do we have form defaults in the schema under the x-schema-form-attribute?\n                        if (def.schema['x-schema-form'] && angular.isObject(def.schema['x-schema-form'])) {\n                            def = angular.extend(def, def.schema['x-schema-form']);\n                        }\n\n                        return def;\n                    }\n                }\n            }\n        };\n\n        //Creates a form object with all common properties\n        var stdFormObj = function(name, schema, options) {\n            options = options || {};\n            var f = options.global && options.global.formDefaults ?\n                angular.copy(options.global.formDefaults) : {};\n            if (options.global && options.global.supressPropertyTitles === true) {\n                f.title = schema.title;\n            } else {\n                f.title = schema.title || name;\n            }\n\n            if (schema.description) {\n                f.description = schema.description;\n            }\n            if (options.required === true || schema.required === true) {\n                f.required = true;\n            }\n            if (schema.maxLength) {\n                f.maxlength = schema.maxLength;\n            }\n            if (schema.minLength) {\n                f.minlength = schema.minLength;\n            }\n            if (schema.readOnly || schema.readonly) {\n                f.readonly = true;\n            }\n            if (schema.minimum) {\n                f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0);\n            }\n            if (schema.maximum) {\n                f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0);\n            }\n\n            // Non standard attributes (DONT USE DEPRECATED)\n            // If you must set stuff like this in the schema use the x-schema-form attribute\n            if (schema.validationMessage) {\n                f.validationMessage = schema.validationMessage;\n            }\n            if (schema.enumNames) {\n                f.titleMap = canonicalTitleMap(schema.enumNames, schema['enum']);\n            }\n            f.schema = schema;\n\n            // Ng model options doesn't play nice with undefined, might be defined\n            // globally though\n            f.ngModelOptions = f.ngModelOptions || {};\n\n            return f;\n        };\n\n        var text = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'string' && !schema['enum']) {\n                var f = stdFormObj(name, schema, options);\n                f.key = options.path;\n                f.type = 'text';\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n                return f;\n            }\n        };\n\n        //default in json form for number and integer is a text field\n        //input type=\"number\" would be more suitable don't ya think?\n        var number = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'number') {\n                var f = stdFormObj(name, schema, options);\n                f.key = options.path;\n                f.type = 'number';\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n                return f;\n            }\n        };\n\n        var integer = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'integer') {\n                var f = stdFormObj(name, schema, options);\n                f.key = options.path;\n                f.type = 'number';\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n                return f;\n            }\n        };\n\n        var checkbox = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'boolean') {\n                var f = stdFormObj(name, schema, options);\n                f.key = options.path;\n                f.type = 'checkbox';\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n                return f;\n            }\n        };\n\n        var select = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'string' && schema['enum']) {\n                var f = stdFormObj(name, schema, options);\n                f.key = options.path;\n                f.type = 'select';\n                if (!f.titleMap) {\n                    f.titleMap = enumToTitleMap(schema['enum']);\n                }\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n                return f;\n            }\n        };\n\n        var checkboxes = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'array' && schema.items && schema.items['enum']) {\n                var f = stdFormObj(name, schema, options);\n                f.key = options.path;\n                f.type = 'checkboxes';\n                if (!f.titleMap) {\n                    f.titleMap = enumToTitleMap(schema.items['enum']);\n                }\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n                return f;\n            }\n        };\n\n        var fieldset = function(name, schema, options) {\n            if (stripNullType(schema.type) === 'object') {\n                var f = stdFormObj(name, schema, options);\n                f.type = 'fieldset';\n                f.items = [];\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n\n                //recurse down into properties\n                angular.forEach(schema.properties, function(v, k) {\n                    var path = options.path.slice();\n                    path.push(k);\n                    if (options.ignore[sfPathProvider.stringify(path)] !== true) {\n                        var required = schema.required && schema.required.indexOf(k) !== -1;\n\n                        var def = defaultFormDefinition(k, v, {\n                            path: path,\n                            required: required || false,\n                            lookup: options.lookup,\n                            ignore: options.ignore,\n                            global: options.global\n                        });\n                        if (def) {\n                            f.items.push(def);\n                        }\n                    }\n                });\n\n                return f;\n            }\n\n        };\n\n        var array = function(name, schema, options) {\n\n            if (stripNullType(schema.type) === 'array') {\n                var f = stdFormObj(name, schema, options);\n                f.type = 'array';\n                f.key = options.path;\n                options.lookup[sfPathProvider.stringify(options.path)] = f;\n\n                var required = schema.required &&\n                    schema.required.indexOf(options.path[options.path.length - 1]) !== -1;\n\n                // The default is to always just create one child. This works since if the\n                // schemas items declaration is of type: \"object\" then we get a fieldset.\n                // We also follow json form notatation, adding empty brackets \"[]\" to\n                // signify arrays.\n\n                var arrPath = options.path.slice();\n                arrPath.push('');\n\n                f.items = [defaultFormDefinition(name, schema.items, {\n                    path: arrPath,\n                    required: required || false,\n                    lookup: options.lookup,\n                    ignore: options.ignore,\n                    global: options.global\n                })];\n\n                return f;\n            }\n\n        };\n\n        //First sorted by schema type then a list.\n        //Order has importance. First handler returning an form snippet will be used.\n        var defaults = {\n            string: [select, text],\n            object: [fieldset],\n            number: [number],\n            integer: [integer],\n            boolean: [checkbox],\n            array: [checkboxes, array]\n        };\n\n        var postProcessFn = function(form) {\n            return form;\n        };\n\n        /**\n         * Provider API\n         */\n        this.defaults = defaults;\n        this.stdFormObj = stdFormObj;\n        this.defaultFormDefinition = defaultFormDefinition;\n\n        /**\n         * Register a post process function.\n         * This function is called with the fully merged\n         * form definition (i.e. after merging with schema)\n         * and whatever it returns is used as form.\n         */\n        this.postProcess = function(fn) {\n            postProcessFn = fn;\n        };\n\n        /**\n         * Append default form rule\n         * @param {string}   type json schema type\n         * @param {Function} rule a function(propertyName,propertySchema,options) that returns a form\n         *                        definition or undefined\n         */\n        this.appendRule = function(type, rule) {\n            if (!defaults[type]) {\n                defaults[type] = [];\n            }\n            defaults[type].push(rule);\n        };\n\n        /**\n         * Prepend default form rule\n         * @param {string}   type json schema type\n         * @param {Function} rule a function(propertyName,propertySchema,options) that returns a form\n         *                        definition or undefined\n         */\n        this.prependRule = function(type, rule) {\n            if (!defaults[type]) {\n                defaults[type] = [];\n            }\n            defaults[type].unshift(rule);\n        };\n\n        /**\n         * Utility function to create a standard form object.\n         * This does *not* set the type of the form but rather all shared attributes.\n         * You probably want to start your rule with creating the form with this method\n         * then setting type and any other values you need.\n         * @param {Object} schema\n         * @param {Object} options\n         * @return {Object} a form field defintion\n         */\n        this.createStandardForm = stdFormObj;\n        /* End Provider API */\n\n        this.$get = function() {\n\n            var service = {};\n\n            service.merge = function(schema, form, ignore, options, readonly, asyncTemplates) {\n                form = form || ['*'];\n                options = options || {};\n\n                // Get readonly from root object\n                readonly = readonly || schema.readonly || schema.readOnly;\n\n                var stdForm = service.defaults(schema, ignore, options);\n\n                //simple case, we have a \"*\", just put the stdForm there\n                var idx = form.indexOf('*');\n                if (idx !== -1) {\n                    form = form.slice(0, idx)\n                        .concat(stdForm.form)\n                        .concat(form.slice(idx + 1));\n                }\n\n                //ok let's merge!\n                //We look at the supplied form and extend it with schema standards\n                var lookup = stdForm.lookup;\n\n                return postProcessFn(form.map(function(obj) {\n\n                    //handle the shortcut with just a name\n                    if (typeof obj === 'string') {\n                        obj = { key: obj };\n                    }\n\n                    if (obj.key) {\n                        if (typeof obj.key === 'string') {\n                            obj.key = sfPathProvider.parse(obj.key);\n                        }\n                    }\n\n                    //If it has a titleMap make sure it's a list\n                    if (obj.titleMap) {\n                        obj.titleMap = canonicalTitleMap(obj.titleMap);\n                    }\n\n                    //\n                    if (obj.itemForm) {\n                        obj.items = [];\n                        var str = sfPathProvider.stringify(obj.key);\n                        var stdForm = lookup[str];\n                        angular.forEach(stdForm.items, function(item) {\n                            var o = angular.copy(obj.itemForm);\n                            o.key = item.key;\n                            obj.items.push(o);\n                        });\n                    }\n\n                    //extend with std form from schema.\n                    if (obj.key) {\n                        var strid = sfPathProvider.stringify(obj.key);\n                        if (lookup[strid]) {\n                            var schemaDefaults = lookup[strid];\n                            angular.forEach(schemaDefaults, function(value, attr) {\n                                if (obj[attr] === undefined) {\n                                    obj[attr] = schemaDefaults[attr];\n                                }\n                            });\n                        }\n                    }\n\n                    // Are we inheriting readonly?\n                    if (readonly === true) { // Inheriting false is not cool.\n                        obj.readonly = true;\n                    }\n\n                    //if it's a type with items, merge 'em!\n                    if (obj.items) {\n                        obj.items = service.merge(schema, obj.items, ignore, options, obj.readonly, asyncTemplates);\n                    }\n\n                    //if its has tabs, merge them also!\n                    if (obj.tabs) {\n                        angular.forEach(obj.tabs, function(tab) {\n                            tab.items = service.merge(schema, tab.items, ignore, options, obj.readonly, asyncTemplates);\n                        });\n                    }\n\n                    // Special case: checkbox\n                    // Since have to ternary state we need a default\n                    if (obj.type === 'checkbox' && angular.isUndefined(obj.schema['default'])) {\n                        obj.schema['default'] = false;\n                    }\n\n                    // Special case: template type with tempplateUrl that's needs to be loaded before rendering\n                    // TODO: this is not a clean solution. Maybe something cleaner can be made when $ref support\n                    // is introduced since we need to go async then anyway\n                    if (asyncTemplates && obj.type === 'template' && !obj.template && obj.templateUrl) {\n                        asyncTemplates.push(obj);\n                    }\n\n                    return obj;\n                }));\n            };\n\n            /**\n             * Create form defaults from schema\n             */\n            service.defaults = function(schema, ignore, globalOptions) {\n                var form = [];\n                var lookup = {}; //Map path => form obj for fast lookup in merging\n                ignore = ignore || {};\n                globalOptions = globalOptions || {};\n\n                if (stripNullType(schema.type) === 'object') {\n                    angular.forEach(schema.properties, function(v, k) {\n                        if (ignore[k] !== true) {\n                            var required = schema.required && schema.required.indexOf(k) !== -1;\n                            var def = defaultFormDefinition(k, v, {\n                                path: [k], // Path to this property in bracket notation.\n                                lookup: lookup, // Extra map to register with. Optimization for merger.\n                                ignore: ignore, // The ignore list of paths (sans root level name)\n                                required: required, // Is it required? (v4 json schema style)\n                                global: globalOptions // Global options, including form defaults\n                            });\n                            if (def) {\n                                form.push(def);\n                            }\n                        }\n                    });\n\n                } else {\n                    throw new Error('Not implemented. Only type \"object\" allowed at root level of schema.');\n                }\n                return { form: form, lookup: lookup };\n            };\n\n            //Utility functions\n            /**\n             * Traverse a schema, applying a function(schema,path) on every sub schema\n             * i.e. every property of an object.\n             */\n            service.traverseSchema = function(schema, fn, path, ignoreArrays) {\n                ignoreArrays = angular.isDefined(ignoreArrays) ? ignoreArrays : true;\n\n                path = path || [];\n\n                var traverse = function(schema, fn, path) {\n                    fn(schema, path);\n                    angular.forEach(schema.properties, function(prop, name) {\n                        var currentPath = path.slice();\n                        currentPath.push(name);\n                        traverse(prop, fn, currentPath);\n                    });\n\n                    //Only support type \"array\" which have a schema as \"items\".\n                    if (!ignoreArrays && schema.items) {\n                        var arrPath = path.slice();\n                        arrPath.push('');\n                        traverse(schema.items, fn, arrPath);\n                    }\n                };\n\n                traverse(schema, fn, path || []);\n            };\n\n            service.traverseForm = function(form, fn) {\n                fn(form);\n                angular.forEach(form.items, function(f) {\n                    service.traverseForm(f, fn);\n                });\n\n                if (form.tabs) {\n                    angular.forEach(form.tabs, function(tab) {\n                        angular.forEach(tab.items, function(f) {\n                            service.traverseForm(f, fn);\n                        });\n                    });\n                }\n            };\n\n            return service;\n        };\n\n    }]);\n\n    /*  Common code for validating a value against its form and schema definition */\n    /* global tv4 */\n    angular.module('schemaForm').factory('sfValidator', [function() {\n\n        var validator = {};\n\n        /**\n         * Validate a value against its form definition and schema.\n         * The value should either be of proper type or a string, some type\n         * coercion is applied.\n         *\n         * @param {Object} form A merged form definition, i.e. one with a schema.\n         * @param {Any} value the value to validate.\n         * @return a tv4js result object.\n         */\n        validator.validate = function(form, value) {\n            if (!form) {\n                return { valid: true };\n            }\n            var schema = form.schema;\n\n            if (!schema) {\n                return { valid: true };\n            }\n\n            // Input of type text and textareas will give us a viewValue of ''\n            // when empty, this is a valid value in a schema and does not count as something\n            // that breaks validation of 'required'. But for our own sanity an empty field should\n            // not validate if it's required.\n            if (value === '') {\n                value = undefined;\n            }\n\n            // Numbers fields will give a null value, which also means empty field\n            if (form.type === 'number' && value === null) {\n                value = undefined;\n            }\n\n            // Version 4 of JSON Schema has the required property not on the\n            // property itself but on the wrapping object. Since we like to test\n            // only this property we wrap it in a fake object.\n            var wrap = { type: 'object', 'properties': {} };\n            var propName = form.key[form.key.length - 1];\n            wrap.properties[propName] = schema;\n\n            if (form.required) {\n                wrap.required = [propName];\n            }\n            var valueWrap = {};\n            if (angular.isDefined(value)) {\n                valueWrap[propName] = value;\n            }\n            return tv4.validateResult(valueWrap, wrap);\n\n        };\n\n        return validator;\n    }]);\n\n    /**\n     * A version of ng-changed that only listens if\n     * there is actually a onChange defined on the form\n     *\n     * Takes the form definition as argument.\n     * If the form definition has a \"onChange\" defined as either a function or\n     */\n    angular.module('schemaForm').directive('sfChanged', function() {\n        return {\n            require: 'ngModel',\n            restrict: 'AC',\n            scope: false,\n            link: function(scope, element, attrs, ctrl) {\n                var form = scope.$eval(attrs.sfChanged);\n                //\"form\" is really guaranteed to be here since the decorator directive\n                //waits for it. But best be sure.\n                if (form && form.onChange) {\n                    ctrl.$viewChangeListeners.push(function() {\n                        if (angular.isFunction(form.onChange)) {\n                            form.onChange(ctrl.$modelValue, form);\n                        } else {\n                            scope.evalExpr(form.onChange, { 'modelValue': ctrl.$modelValue, form: form });\n                        }\n                    });\n                }\n            }\n        };\n    });\n\n    angular.module('schemaForm').directive('sfField', ['$parse', '$compile', '$http', '$templateCache', '$interpolate', '$q', 'sfErrorMessage',\n        'sfPath', 'sfSelect',\n        function($parse, $compile, $http, $templateCache, $interpolate, $q, sfErrorMessage,\n            sfPath, sfSelect) {\n\n            return {\n                restrict: 'AE',\n                replace: false,\n                transclude: false,\n                scope: true,\n                require: '^sfSchema',\n                link: {\n                    pre: function(scope, element, attrs, sfSchema) {\n                        //The ngModelController is used in some templates and\n                        //is needed for error messages,\n                        scope.$on('schemaFormPropagateNgModelController', function(event, ngModel) {\n                            event.stopPropagation();\n                            event.preventDefault();\n                            scope.ngModel = ngModel;\n                        });\n\n                        // Fetch our form.\n                        scope.form = sfSchema.lookup['f' + attrs.sfField];\n                    },\n                    post: function(scope, element, attrs, sfSchema) {\n                        //Keep error prone logic from the template\n                        scope.showTitle = function() {\n                            return scope.form && scope.form.notitle !== true && scope.form.title;\n                        };\n\n                        scope.listToCheckboxValues = function(list) {\n                            var values = {};\n                            angular.forEach(list, function(v) {\n                                values[v] = true;\n                            });\n                            return values;\n                        };\n\n                        scope.checkboxValuesToList = function(values) {\n                            var lst = [];\n                            angular.forEach(values, function(v, k) {\n                                if (v) {\n                                    lst.push(k);\n                                }\n                            });\n                            return lst;\n                        };\n\n                        scope.buttonClick = function($event, form) {\n                            if (angular.isFunction(form.onClick)) {\n                                form.onClick($event, form);\n                            } else if (angular.isString(form.onClick)) {\n                                if (sfSchema) {\n                                    //evaluating in scope outside of sfSchemas isolated scope\n                                    sfSchema.evalInParentScope(form.onClick, { '$event': $event, form: form });\n                                } else {\n                                    scope.$eval(form.onClick, { '$event': $event, form: form });\n                                }\n                            }\n                        };\n\n                        /**\n                         * Evaluate an expression, i.e. scope.$eval\n                         * but do it in sfSchemas parent scope sf-schema directive is used\n                         * @param {string} expression\n                         * @param {Object} locals (optional)\n                         * @return {Any} the result of the expression\n                         */\n                        scope.evalExpr = function(expression, locals) {\n                            if (sfSchema) {\n                                //evaluating in scope outside of sfSchemas isolated scope\n                                return sfSchema.evalInParentScope(expression, locals);\n                            }\n\n                            return scope.$eval(expression, locals);\n                        };\n\n                        /**\n                         * Evaluate an expression, i.e. scope.$eval\n                         * in this decorators scope\n                         * @param {string} expression\n                         * @param {Object} locals (optional)\n                         * @return {Any} the result of the expression\n                         */\n                        scope.evalInScope = function(expression, locals) {\n                            if (expression) {\n                                return scope.$eval(expression, locals);\n                            }\n                        };\n\n                        /**\n                         * Interpolate the expression.\n                         * Similar to `evalExpr()` and `evalInScope()`\n                         * but will not fail if the expression is\n                         * text that contains spaces.\n                         *\n                         * Use the Angular `{{ interpolation }}`\n                         * braces to access properties on `locals`.\n                         *\n                         * @param  {string} content The string to interpolate.\n                         * @param  {Object} locals (optional) Properties that may be accessed in the\n                         *                         `expression` string.\n                         * @return {Any} The result of the expression or `undefined`.\n                         */\n                        scope.interp = function(expression, locals) {\n                            return (expression && $interpolate(expression)(locals));\n                        };\n\n                        //This works since we get the ngModel from the array or the schema-validate directive.\n                        scope.hasSuccess = function() {\n                            if (!scope.ngModel) {\n                                return false;\n                            }\n                            if (scope.options && scope.options.pristine &&\n                                scope.options.pristine.success === false) {\n                                return scope.ngModel.$valid && !scope.ngModel.$pristine && !scope.ngModel.$isEmpty(scope.ngModel.$modelValue);\n                            } else {\n                                return scope.ngModel.$valid &&\n                                    (!scope.ngModel.$pristine || !scope.ngModel.$isEmpty(scope.ngModel.$modelValue));\n                            }\n                        };\n\n                        scope.hasError = function() {\n                            if (!scope.ngModel) {\n                                return false;\n                            }\n                            if (!scope.options || !scope.options.pristine || scope.options.pristine.errors !== false) {\n                                // Show errors in pristine forms. The default.\n                                // Note that \"validateOnRender\" option defaults to *not* validate initial form.\n                                // so as a default there won't be any error anyway, but if the model is modified\n                                // from the outside the error will show even if the field is pristine.\n                                return scope.ngModel.$invalid;\n                            } else {\n                                // Don't show errors in pristine forms.\n                                return scope.ngModel.$invalid && !scope.ngModel.$pristine;\n                            }\n                        };\n\n                        /**\n                         * DEPRECATED: use sf-messages instead.\n                         * Error message handler\n                         * An error can either be a schema validation message or a angular js validtion\n                         * error (i.e. required)\n                         */\n                        scope.errorMessage = function(schemaError) {\n                            return sfErrorMessage.interpolate(\n                                (schemaError && schemaError.code + '') || 'default',\n                                (scope.ngModel && scope.ngModel.$modelValue) || '',\n                                (scope.ngModel && scope.ngModel.$viewValue) || '',\n                                scope.form,\n                                scope.options && scope.options.validationMessage\n                            );\n                        };\n\n                        var form = scope.form;\n\n                        // Where there is a key there is probably a ngModel\n                        if (form.key) {\n                            // It looks better with dot notation.\n                            scope.$on(\n                                'schemaForm.error.' + form.key.join('.'),\n                                function(event, error, validationMessage, validity) {\n                                    if (validationMessage === true || validationMessage === false) {\n                                        validity = validationMessage;\n                                        validationMessage = undefined;\n                                    }\n\n                                    if (scope.ngModel && error) {\n                                        if (scope.ngModel.$setDirty) {\n                                            scope.ngModel.$setDirty();\n                                        } else {\n                                            // FIXME: Check that this actually works on 1.2\n                                            scope.ngModel.$dirty = true;\n                                            scope.ngModel.$pristine = false;\n                                        }\n\n                                        // Set the new validation message if one is supplied\n                                        // Does not work when validationMessage is just a string.\n                                        if (validationMessage) {\n                                            if (!form.validationMessage) {\n                                                form.validationMessage = {};\n                                            }\n                                            form.validationMessage[error] = validationMessage;\n                                        }\n\n                                        scope.ngModel.$setValidity(error, validity === true);\n\n                                        if (validity === true) {\n                                            // Setting or removing a validity can change the field to believe its valid\n                                            // but its not. So lets trigger its validation as well.\n                                            scope.$broadcast('schemaFormValidate');\n                                        }\n                                    }\n                                }\n                            );\n\n                            // Clean up the model when the corresponding form field is $destroy-ed.\n                            // Default behavior can be supplied as a globalOption, and behavior can be overridden\n                            // in the form definition.\n                            scope.$on('$destroy', function() {\n                                // If the entire schema form is destroyed we don't touch the model\n                                if (!scope.externalDestructionInProgress) {\n                                    var destroyStrategy = form.destroyStrategy ||\n                                        (scope.options && scope.options.destroyStrategy) || 'remove';\n                                    // No key no model, and we might have strategy 'retain'\n                                    if (form.key && destroyStrategy !== 'retain') {\n\n                                        // Get the object that has the property we wan't to clear.\n                                        var obj = scope.model;\n                                        if (form.key.length > 1) {\n                                            obj = sfSelect(form.key.slice(0, form.key.length - 1), obj);\n                                        }\n\n                                        // We can get undefined here if the form hasn't been filled out entirely\n                                        if (obj === undefined) {\n                                            return;\n                                        }\n\n                                        // Type can also be a list in JSON Schema\n                                        var type = (form.schema && form.schema.type) || '';\n\n                                        // Empty means '',{} and [] for appropriate types and undefined for the rest\n                                        //console.log('destroy', destroyStrategy, form.key, type, obj);\n                                        if (destroyStrategy === 'empty' && type.indexOf('string') !== -1) {\n                                            obj[form.key.slice(-1)] = '';\n                                        } else if (destroyStrategy === 'empty' && type.indexOf('object') !== -1) {\n                                            obj[form.key.slice(-1)] = {};\n                                        } else if (destroyStrategy === 'empty' && type.indexOf('array') !== -1) {\n                                            obj[form.key.slice(-1)] = [];\n                                        } else if (destroyStrategy === 'null') {\n                                            obj[form.key.slice(-1)] = null;\n                                        } else {\n                                            delete obj[form.key.slice(-1)];\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }\n            };\n        }\n    ]);\n\n    angular.module('schemaForm').directive('sfMessage', ['$injector', 'sfErrorMessage', function($injector, sfErrorMessage) {\n\n        //Inject sanitizer if it exists\n        var $sanitize = $injector.has('$sanitize') ?\n            $injector.get('$sanitize') : function(html) {\n                return html;\n            };\n\n        return {\n            scope: false,\n            restrict: 'EA',\n            link: function(scope, element, attrs) {\n\n                var message = '';\n                if (attrs.sfMessage) {\n                    scope.$watch(attrs.sfMessage, function(msg) {\n                        if (msg) {\n                            message = $sanitize(msg);\n                            update(!!scope.ngModel);\n                        }\n                    });\n                }\n\n                var currentMessage;\n                // Only call html() if needed.\n                var setMessage = function(msg) {\n                    if (msg !== currentMessage) {\n                        element.html(msg);\n                        currentMessage = msg;\n                    }\n                };\n\n                var update = function(checkForErrors) {\n                    if (checkForErrors) {\n                        if (!scope.hasError()) {\n                            setMessage(message);\n                        } else {\n                            var errors = [];\n                            angular.forEach(scope.ngModel && scope.ngModel.$error, function(status, code) {\n                                if (status) {\n                                    // if true then there is an error\n                                    // Angular 1.3 removes properties, so we will always just have errors.\n                                    // Angular 1.2 sets them to false.\n                                    errors.push(code);\n                                }\n                            });\n\n                            // In Angular 1.3 we use one $validator to stop the model value from getting updated.\n                            // this means that we always end up with a 'schemaForm' error.\n                            errors = errors.filter(function(e) {\n                                return e !== 'schemaForm';\n                            });\n\n                            // We only show one error.\n                            // TODO: Make that optional\n                            var error = errors[0];\n\n                            if (error) {\n                                setMessage(sfErrorMessage.interpolate(\n                                    error,\n                                    scope.ngModel.$modelValue,\n                                    scope.ngModel.$viewValue,\n                                    scope.form,\n                                    scope.options && scope.options.validationMessage\n                                ));\n                            } else {\n                                setMessage(message);\n                            }\n                        }\n                    } else {\n                        setMessage(message);\n                    }\n                };\n\n                // Update once.\n                update();\n\n                var once = scope.$watch('ngModel', function(ngModel) {\n                    if (ngModel) {\n                        // We also listen to changes of the model via parsers and formatters.\n                        // This is since both the error message can change and given a pristine\n                        // option to not show errors the ngModel.$error might not have changed\n                        // but we're not pristine any more so we should change!\n                        ngModel.$parsers.push(function(val) {\n                            update(true);\n                            return val;\n                        });\n                        ngModel.$formatters.push(function(val) {\n                            update(true);\n                            return val;\n                        });\n                        once();\n                    }\n                });\n\n                // We watch for changes in $error\n                scope.$watchCollection('ngModel.$error', function() {\n                    update(!!scope.ngModel);\n                });\n\n            }\n        };\n    }]);\n\n    /**\n     * Directive that handles the model arrays\n     */\n    angular.module('schemaForm').directive('sfNewArray', ['sfSelect', 'sfPath', 'schemaForm',\n        function(sel, sfPath, schemaForm) {\n            return {\n                scope: false,\n                link: function(scope, element, attrs) {\n                    scope.min = 0;\n\n                    scope.modelArray = scope.$eval(attrs.sfNewArray);\n\n                    // We need to have a ngModel to hook into validation. It doesn't really play well with\n                    // arrays though so we both need to trigger validation and onChange.\n                    // So we watch the value as well. But watching an array can be tricky. We wan't to know\n                    // when it changes so we can validate,\n                    var watchFn = function() {\n                        //scope.modelArray = modelArray;\n                        scope.modelArray = scope.$eval(attrs.sfNewArray);\n                        // validateField method is exported by schema-validate\n                        if (scope.ngModel && scope.ngModel.$pristine && scope.firstDigest &&\n                            (!scope.options || scope.options.validateOnRender !== true)) {\n                            return;\n                        } else if (scope.validateField) {\n                            scope.validateField();\n                        }\n                    };\n\n                    var onChangeFn = function() {\n                        if (scope.form && scope.form.onChange) {\n                            if (angular.isFunction(scope.form.onChange)) {\n                                scope.form.onChange(scope.modelArray, scope.form);\n                            } else {\n                                scope.evalExpr(scope.form.onChange, { 'modelValue': scope.modelArray, form: scope.form });\n                            }\n                        }\n                    };\n\n                    // If model is undefined make sure it gets set.\n                    var getOrCreateModel = function() {\n                        var model = scope.modelArray;\n                        if (!model) {\n                            var selection = sfPath.parse(attrs.sfNewArray);\n                            model = [];\n                            sel(selection, scope, model);\n                            scope.modelArray = model;\n                        }\n                        return model;\n                    };\n\n                    // We need the form definition to make a decision on how we should listen.\n                    var once = scope.$watch('form', function(form) {\n                        if (!form) {\n                            return;\n                        }\n\n                        // Always start with one empty form unless configured otherwise.\n                        // Special case: don't do it if form has a titleMap\n                        if (!form.titleMap && form.startEmpty !== true && (!scope.modelArray || scope.modelArray.length === 0)) {\n                            scope.appendToArray();\n                        }\n\n                        // If we have \"uniqueItems\" set to true, we must deep watch for changes.\n                        if (scope.form && scope.form.schema && scope.form.schema.uniqueItems === true) {\n                            scope.$watch(attrs.sfNewArray, watchFn, true);\n\n                            // We still need to trigger onChange though.\n                            scope.$watch([attrs.sfNewArray, attrs.sfNewArray + '.length'], onChangeFn);\n\n                        } else {\n                            // Otherwise we like to check if the instance of the array has changed, or if something\n                            // has been added/removed.\n                            if (scope.$watchGroup) {\n                                scope.$watchGroup([attrs.sfNewArray, attrs.sfNewArray + '.length'], function() {\n                                    watchFn();\n                                    onChangeFn();\n                                });\n                            } else {\n                                // Angular 1.2 support\n                                scope.$watch(attrs.sfNewArray, function() {\n                                    watchFn();\n                                    onChangeFn();\n                                });\n                                scope.$watch(attrs.sfNewArray + '.length', function() {\n                                    watchFn();\n                                    onChangeFn();\n                                });\n                            }\n                        }\n\n                        // Title Map handling\n                        // If form has a titleMap configured we'd like to enable looping over\n                        // titleMap instead of modelArray, this is used for intance in\n                        // checkboxes. So instead of variable number of things we like to create\n                        // a array value from a subset of values in the titleMap.\n                        // The problem here is that ng-model on a checkbox doesn't really map to\n                        // a list of values. This is here to fix that.\n                        if (form.titleMap && form.titleMap.length > 0) {\n                            scope.titleMapValues = [];\n\n                            // We watch the model for changes and the titleMapValues to reflect\n                            // the modelArray\n                            var updateTitleMapValues = function(arr) {\n                                scope.titleMapValues = [];\n                                arr = arr || [];\n\n                                form.titleMap.forEach(function(item) {\n                                    scope.titleMapValues.push(arr.indexOf(item.value) !== -1);\n                                });\n                            };\n                            //Catch default values\n                            updateTitleMapValues(scope.modelArray);\n\n                            // TODO: Refactor and see if we can get rid of this watch by piggy backing on the\n                            // validation watch.\n                            scope.$watchCollection('modelArray', updateTitleMapValues);\n\n                            //To get two way binding we also watch our titleMapValues\n                            scope.$watchCollection('titleMapValues', function(vals, old) {\n                                if (vals && vals !== old) {\n                                    var arr = getOrCreateModel();\n\n                                    // Apparently the fastest way to clear an array, readable too.\n                                    // http://jsperf.com/array-destroy/32\n                                    while (arr.length > 0) {\n                                        arr.pop();\n                                    }\n                                    form.titleMap.forEach(function(item, index) {\n                                        if (vals[index]) {\n                                            arr.push(item.value);\n                                        }\n                                    });\n\n                                    // Time to validate the rebuilt array.\n                                    // validateField method is exported by schema-validate\n                                    if (scope.validateField) {\n                                        scope.validateField();\n                                    }\n                                }\n                            });\n                        }\n\n                        once();\n                    });\n\n                    scope.appendToArray = function() {\n                        var empty;\n\n                        // Create and set an array if needed.\n                        var model = getOrCreateModel();\n\n                        // Same old add empty things to the array hack :(\n                        if (scope.form && scope.form.schema && scope.form.schema.items) {\n\n                            var items = scope.form.schema.items;\n                            if (items.type && items.type.indexOf('object') !== -1) {\n                                empty = {};\n\n                                // Check for possible defaults\n                                if (!scope.options || scope.options.setSchemaDefaults !== false) {\n                                    empty = angular.isDefined(items['default']) ? items['default'] : empty;\n\n                                    // Check for defaults further down in the schema.\n                                    // If the default instance sets the new array item to something falsy, i.e. null\n                                    // then there is no need to go further down.\n                                    if (empty) {\n                                        schemaForm.traverseSchema(items, function(prop, path) {\n                                            if (angular.isDefined(prop['default'])) {\n                                                sel(path, empty, prop['default']);\n                                            }\n                                        });\n                                    }\n                                }\n\n                            } else if (items.type && items.type.indexOf('array') !== -1) {\n                                empty = [];\n                                if (!scope.options || scope.options.setSchemaDefaults !== false) {\n                                    empty = items['default'] || empty;\n                                }\n                            } else {\n                                // No type? could still have defaults.\n                                if (!scope.options || scope.options.setSchemaDefaults !== false) {\n                                    empty = items['default'] || empty;\n                                }\n                            }\n                        }\n                        model.push(empty);\n\n                        return model;\n                    };\n\n                    scope.deleteFromArray = function(index) {\n                        var model = scope.modelArray;\n                        if (model) {\n                            model.splice(index, 1);\n                        }\n                        return model;\n                    };\n\n                    // For backwards compatability, i.e. when a bootstrap-decorator tag is used\n                    // as child to the array.\n                    var setIndex = function(index) {\n                        return function(form) {\n                            if (form.key) {\n                                form.key[form.key.indexOf('')] = index;\n                            }\n                        };\n                    };\n                    var formDefCache = {};\n                    scope.copyWithIndex = function(index) {\n                        var form = scope.form;\n                        if (!formDefCache[index]) {\n\n                            // To be more compatible with JSON Form we support an array of items\n                            // in the form definition of \"array\" (the schema just a value).\n                            // for the subforms code to work this means we wrap everything in a\n                            // section. Unless there is just one.\n                            var subForm = form.items[0];\n                            if (form.items.length > 1) {\n                                subForm = {\n                                    type: 'section',\n                                    items: form.items.map(function(item) {\n                                        item.ngModelOptions = form.ngModelOptions;\n                                        if (angular.isUndefined(item.readonly)) {\n                                            item.readonly = form.readonly;\n                                        }\n                                        return item;\n                                    })\n                                };\n                            }\n\n                            if (subForm) {\n                                var copy = angular.copy(subForm);\n                                copy.arrayIndex = index;\n                                schemaForm.traverseForm(copy, setIndex(index));\n                                formDefCache[index] = copy;\n                            }\n                        }\n                        return formDefCache[index];\n                    };\n\n                }\n            };\n        }\n    ]);\n\n    /*\n     FIXME: real documentation\n     <form sf-form=\"form\"  sf-schema=\"schema\" sf-decorator=\"foobar\"></form>\n     */\n\n    angular.module('schemaForm')\n        .directive('sfSchema', ['$compile', '$http', '$templateCache', '$q', 'schemaForm', 'schemaFormDecorators', 'sfSelect', 'sfPath', 'sfBuilder',\n            function($compile, $http, $templateCache, $q, schemaForm, schemaFormDecorators, sfSelect, sfPath, sfBuilder) {\n\n                return {\n                    scope: {\n                        schema: '=sfSchema',\n                        initialForm: '=sfForm',\n                        model: '=sfModel',\n                        options: '=sfOptions'\n                    },\n                    controller: ['$scope', function($scope) {\n                        this.evalInParentScope = function(expr, locals) {\n                            return $scope.$parent.$eval(expr, locals);\n                        };\n\n                        // Set up form lookup map\n                        var that = this;\n                        $scope.lookup = function(lookup) {\n                            if (lookup) {\n                                that.lookup = lookup;\n                            }\n                            return that.lookup;\n                        };\n                    }],\n                    replace: false,\n                    restrict: 'A',\n                    transclude: true,\n                    require: '?form',\n                    link: function(scope, element, attrs, formCtrl, transclude) {\n\n                        //expose form controller on scope so that we don't force authors to use name on form\n                        scope.formCtrl = formCtrl;\n\n                        //We'd like to handle existing markup,\n                        //besides using it in our template we also\n                        //check for ng-model and add that to an ignore list\n                        //i.e. even if form has a definition for it or form is [\"*\"]\n                        //we don't generate it.\n                        var ignore = {};\n                        transclude(scope, function(clone) {\n                            clone.addClass('schema-form-ignore');\n                            element.prepend(clone);\n\n                            if (element[0].querySelectorAll) {\n                                var models = element[0].querySelectorAll('[ng-model]');\n                                if (models) {\n                                    for (var i = 0; i < models.length; i++) {\n                                        var key = models[i].getAttribute('ng-model');\n                                        //skip first part before .\n                                        ignore[key.substring(key.indexOf('.') + 1)] = true;\n                                    }\n                                }\n                            }\n                        });\n\n                        var lastDigest = {};\n                        var childScope;\n\n                        // Common renderer function, can either be triggered by a watch or by an event.\n                        var render = function(schema, form) {\n                            var asyncTemplates = [];\n                            var merged = schemaForm.merge(schema, form, ignore, scope.options, undefined, asyncTemplates);\n\n                            if (asyncTemplates.length > 0) {\n                                // Pre load all async templates and put them on the form for the builder to use.\n                                $q.all(asyncTemplates.map(function(form) {\n                                    return $http.get(form.templateUrl, { cache: $templateCache }).then(function(res) {\n                                        form.template = res.data;\n                                    });\n                                })).then(function() {\n                                    internalRender(schema, form, merged);\n                                });\n\n                            } else {\n                                internalRender(schema, form, merged);\n                            }\n\n\n                        };\n\n                        var internalRender = function(schema, form, merged) {\n                            // Create a new form and destroy the old one.\n                            // Not doing keeps old form elements hanging around after\n                            // they have been removed from the DOM\n                            // https://github.com/Textalk/angular-schema-form/issues/200\n                            if (childScope) {\n                                // Destroy strategy should not be acted upon\n                                scope.externalDestructionInProgress = true;\n                                childScope.$destroy();\n                                scope.externalDestructionInProgress = false;\n                            }\n                            childScope = scope.$new();\n\n                            //make the form available to decorators\n                            childScope.schemaForm = { form: merged, schema: schema };\n\n                            //clean all but pre existing html.\n                            element.children(':not(.schema-form-ignore)').remove();\n\n                            // Find all slots.\n                            var slots = {};\n                            var slotsFound = element[0].querySelectorAll('*[sf-insert-field]');\n\n                            for (var i = 0; i < slotsFound.length; i++) {\n                                slots[slotsFound[i].getAttribute('sf-insert-field')] = slotsFound[i];\n                            }\n\n                            // if sfUseDecorator is undefined the default decorator is used.\n                            var decorator = schemaFormDecorators.decorator(attrs.sfUseDecorator);\n                            // Use the builder to build it and append the result\n                            var lookup = Object.create(null);\n                            scope.lookup(lookup); // give the new lookup to the controller.\n                            element[0].appendChild(sfBuilder.build(merged, decorator, slots, lookup));\n\n                            // We need to know if we're in the first digest looping\n                            // I.e. just rendered the form so we know not to validate\n                            // empty fields.\n                            childScope.firstDigest = true;\n                            // We use a ordinary timeout since we don't need a digest after this.\n                            setTimeout(function() {\n                                childScope.firstDigest = false;\n                            }, 0);\n\n                            //compile only children\n                            $compile(element.children())(childScope);\n\n                            //ok, now that that is done let's set any defaults\n                            if (!scope.options || scope.options.setSchemaDefaults !== false) {\n                                schemaForm.traverseSchema(schema, function(prop, path) {\n                                    if (angular.isDefined(prop['default'])) {\n                                        var val = sfSelect(path, scope.model);\n                                        if (angular.isUndefined(val)) {\n                                            sfSelect(path, scope.model, prop['default']);\n                                        }\n                                    }\n                                });\n                            }\n\n                            scope.$emit('sf-render-finished', element);\n                        };\n\n                        var defaultForm = ['*'];\n\n                        //Since we are dependant on up to three\n                        //attributes we'll do a common watch\n                        scope.$watch(function() {\n\n                            var schema = scope.schema;\n                            var form = scope.initialForm || defaultForm;\n\n                            //The check for schema.type is to ensure that schema is not {}\n                            if (form && schema && schema.type &&\n                                (lastDigest.form !== form || lastDigest.schema !== schema) &&\n                                Object.keys(schema.properties).length > 0) {\n                                lastDigest.schema = schema;\n                                lastDigest.form = form;\n\n                                render(schema, form);\n                            }\n                        });\n\n                        // We also listen to the event schemaFormRedraw so you can manually trigger a change if\n                        // part of the form or schema is chnaged without it being a new instance.\n                        scope.$on('schemaFormRedraw', function() {\n                            var schema = scope.schema;\n                            var form = scope.initialForm || ['*'];\n                            if (schema) {\n                                render(schema, form);\n                            }\n                        });\n\n                        scope.$on('$destroy', function() {\n                            // Each field listens to the $destroy event so that it can remove any value\n                            // from the model if that field is removed from the form. This is the default\n                            // destroy strategy. But if the entire form (or at least the part we're on)\n                            // gets removed, like when routing away to another page, then we definetly want to\n                            // keep the model intact. So therefore we set a flag to tell the others it's time to just\n                            // let it be.\n                            scope.externalDestructionInProgress = true;\n                        });\n\n                        /**\n                         * Evaluate an expression, i.e. scope.$eval\n                         * but do it in parent scope\n                         *\n                         * @param {String} expression\n                         * @param {Object} locals (optional)\n                         * @return {Any} the result of the expression\n                         */\n                        scope.evalExpr = function(expression, locals) {\n                            return scope.$parent.$eval(expression, locals);\n                        };\n                    }\n                };\n            }\n        ]);\n\n    angular.module('schemaForm').directive('schemaValidate', ['sfValidator', '$parse', 'sfSelect',\n        function(sfValidator, $parse, sfSelect) {\n\n            return {\n                restrict: 'A',\n                scope: false,\n                // We want the link function to be *after* the input directives link function so we get access\n                // the parsed value, ex. a number instead of a string\n                priority: 500,\n                require: 'ngModel',\n                link: function(scope, element, attrs, ngModel) {\n                    // We need the ngModelController on several places,\n                    // most notably for errors.\n                    // So we emit it up to the decorator directive so it can put it on scope.\n                    scope.$emit('schemaFormPropagateNgModelController', ngModel);\n\n                    var error = null;\n                    var form = scope.$eval(attrs.schemaValidate);\n\n                    if (form.copyValueTo) {\n                        ngModel.$viewChangeListeners.push(function() {\n                            var paths = form.copyValueTo;\n                            angular.forEach(paths, function(path) {\n                                sfSelect(path, scope.model, ngModel.$modelValue);\n                            });\n                        });\n                    };\n\n\n                    // Validate against the schema.\n\n                    var validate = function(viewValue) {\n                        //console.log('validate called', viewValue)\n                        //Still might be undefined\n                        if (!form) {\n                            return viewValue;\n                        }\n\n                        // Omit TV4 validation\n                        if (scope.options && scope.options.tv4Validation === false) {\n                            return viewValue;\n                        }\n\n                        var result = sfValidator.validate(form, viewValue);\n                        //console.log('result is', result)\n                        // Since we might have different tv4 errors we must clear all\n                        // errors that start with tv4-\n                        Object.keys(ngModel.$error)\n                            .filter(function(k) {\n                                return k.indexOf('tv4-') === 0;\n                            })\n                            .forEach(function(k) {\n                                ngModel.$setValidity(k, true);\n                            });\n\n                        if (!result.valid) {\n                            // it is invalid, return undefined (no model update)\n                            ngModel.$setValidity('tv4-' + result.error.code, false);\n                            error = result.error;\n\n                            // In Angular 1.3+ return the viewValue, otherwise we inadvertenly\n                            // will trigger a 'parse' error.\n                            // we will stop the model value from updating with our own $validator\n                            // later.\n                            if (ngModel.$validators) {\n                                return viewValue;\n                            }\n                            // Angular 1.2 on the other hand lacks $validators and don't add a 'parse' error.\n                            return undefined;\n                        }\n                        return viewValue;\n                    };\n\n                    // Custom validators, parsers, formatters etc\n                    if (typeof form.ngModel === 'function') {\n                        form.ngModel(ngModel);\n                    }\n\n                    ['$parsers', '$viewChangeListeners', '$formatters'].forEach(function(attr) {\n                        if (form[attr] && ngModel[attr]) {\n                            form[attr].forEach(function(fn) {\n                                ngModel[attr].push(fn);\n                            });\n                        }\n                    });\n\n                    ['$validators', '$asyncValidators'].forEach(function(attr) {\n                        // Check if our version of angular has validators, i.e. 1.3+\n                        if (form[attr] && ngModel[attr]) {\n                            angular.forEach(form[attr], function(fn, name) {\n                                ngModel[attr][name] = fn;\n                            });\n                        }\n                    });\n\n                    // Get in last of the parses so the parsed value has the correct type.\n                    // We don't use $validators since we like to set different errors depending tv4 error codes\n                    ngModel.$parsers.push(validate);\n\n                    // But we do use one custom validator in the case of Angular 1.3 to stop the model from\n                    // updating if we've found an error.\n                    if (ngModel.$validators) {\n                        ngModel.$validators.schemaForm = function() {\n                            //console.log('validators called.')\n                            // Any error and we're out of here!\n                            return !Object.keys(ngModel.$error).some(function(e) {\n                                return e !== 'schemaForm';\n                            });\n                        };\n                    }\n\n                    var schema = form.schema;\n\n                    // A bit ugly but useful.\n                    scope.validateField = function() {\n\n                        // Special case: arrays\n                        // TODO: Can this be generalized in a way that works consistently?\n                        // Just setting the viewValue isn't enough to trigger validation\n                        // since it's the same value. This will be better when we drop\n                        // 1.2 support.\n                        if (schema && schema.type.indexOf('array') !== -1) {\n                            validate(ngModel.$modelValue);\n                        }\n\n                        // We set the viewValue to trigger parsers,\n                        // since modelValue might be empty and validating just that\n                        // might change an existing error to a \"required\" error message.\n                        if (ngModel.$setDirty) {\n\n                            // Angular 1.3+\n                            ngModel.$setDirty();\n                            ngModel.$setViewValue(ngModel.$viewValue);\n                            ngModel.$commitViewValue();\n\n                            // In Angular 1.3 setting undefined as a viewValue does not trigger parsers\n                            // so we need to do a special required check. Fortunately we have $isEmpty\n                            if (form.required && ngModel.$isEmpty(ngModel.$modelValue)) {\n                                ngModel.$setValidity('tv4-302', false);\n                            }\n\n                        } else {\n                            // Angular 1.2\n                            // In angular 1.2 setting a viewValue of undefined will trigger the parser.\n                            // hence required works.\n                            ngModel.$setViewValue(ngModel.$viewValue);\n                        }\n                    };\n\n                    ngModel.$formatters.push(function(val) {\n                        // When a form first loads this will be called for each field.\n                        // we usually don't want that.\n                        if (ngModel.$pristine && scope.firstDigest &&\n                            (!scope.options || scope.options.validateOnRender !== true)) {\n                            return val;\n                        }\n                        validate(ngModel.$modelValue);\n                        return val;\n                    });\n\n                    // Listen to an event so we can validate the input on request\n                    scope.$on('schemaFormValidate', scope.validateField);\n\n                    scope.schemaError = function() {\n                        return error;\n                    };\n                }\n            };\n        }\n    ]);\n\n    return schemaForm;\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-schema-form/dist/schema-form.js\n ** module id = 67\n ** module chunks = 0\n **/"],"sourceRoot":""}