{"version":3,"sources":["webpack:///./~/angular-websocket/dist/angular-websocket.js?c612"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4EAA2E;AAC3E,8EAA6E;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,iCAAiC;AAC5D;AACA;AACA;;AAEA;AACA,4BAA2B,kCAAkC;AAC7D;AACA;AACA;;AAEA;AACA,4BAA2B,kCAAkC;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAC,E","file":"0.03f4023ff4ef27491df1.hot-update.js","sourcesContent":["(function(global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(['module', 'exports', 'angular', 'ws'], factory);\n    } else if (typeof exports !== \"undefined\") {\n        factory(module, exports, require('angular'));\n    } else {\n        var mod = {\n            exports: {}\n        };\n        factory(mod, mod.exports, global.angular);\n        global.angularWebsocket = mod.exports;\n    }\n})(this, function(module, exports, _angular, ws) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n\n    var _angular2 = _interopRequireDefault(_angular);\n\n    function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n            default: obj\n        };\n    }\n\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n    };\n\n    var Socket;\n\n    if (typeof window === 'undefined') {\n        try {\n\n            Socket = ws.Client || ws.client || ws;\n        } catch (e) {}\n    }\n\n    // Browser\n    Socket = Socket || window.WebSocket || window.MozWebSocket;\n\n    var noop = _angular2.default.noop;\n    var objectFreeze = Object.freeze ? Object.freeze : noop;\n    var objectDefineProperty = Object.defineProperty;\n    var isString = _angular2.default.isString;\n    var isFunction = _angular2.default.isFunction;\n    var isDefined = _angular2.default.isDefined;\n    var isObject = _angular2.default.isObject;\n    var isArray = _angular2.default.isArray;\n    var forEach = _angular2.default.forEach;\n    var arraySlice = Array.prototype.slice;\n    // ie8 wat\n    if (!Array.prototype.indexOf) {\n        Array.prototype.indexOf = function(elt /*, from*/ ) {\n            var len = this.length >>> 0;\n            var from = Number(arguments[1]) || 0;\n            from = from < 0 ? Math.ceil(from) : Math.floor(from);\n            if (from < 0) {\n                from += len;\n            }\n\n            for (; from < len; from++) {\n                if (from in this && this[from] === elt) {\n                    return from;\n                }\n            }\n            return -1;\n        };\n    }\n\n    // $WebSocketProvider.$inject = ['$rootScope', '$q', '$timeout', '$websocketBackend'];\n    function $WebSocketProvider($rootScope, $q, $timeout, $websocketBackend) {\n\n        function $WebSocket(url, protocols, options) {\n            if (!options && isObject(protocols) && !isArray(protocols)) {\n                options = protocols;\n                protocols = undefined;\n            }\n\n            this.protocols = protocols;\n            this.url = url || 'Missing URL';\n            this.ssl = /(wss)/i.test(this.url);\n\n            // this.binaryType = '';\n            // this.extensions = '';\n            // this.bufferedAmount = 0;\n            // this.trasnmitting = false;\n            // this.buffer = [];\n\n            // TODO: refactor options to use isDefined\n            this.scope = options && options.scope || $rootScope;\n            this.rootScopeFailover = options && options.rootScopeFailover && true;\n            this.useApplyAsync = options && options.useApplyAsync || false;\n            this.initialTimeout = options && options.initialTimeout || 500; // 500ms\n            this.maxTimeout = options && options.maxTimeout || 5 * 60 * 1000; // 5 minutes\n            this.reconnectIfNotNormalClose = options && options.reconnectIfNotNormalClose || false;\n            this.binaryType = options && options.binaryType || 'blob';\n\n            this._reconnectAttempts = 0;\n            this.sendQueue = [];\n            this.onOpenCallbacks = [];\n            this.onMessageCallbacks = [];\n            this.onErrorCallbacks = [];\n            this.onCloseCallbacks = [];\n\n            objectFreeze(this._readyStateConstants);\n\n            if (url) {\n                this._connect();\n            } else {\n                this._setInternalState(0);\n            }\n        }\n\n        $WebSocket.prototype._readyStateConstants = {\n            'CONNECTING': 0,\n            'OPEN': 1,\n            'CLOSING': 2,\n            'CLOSED': 3,\n            'RECONNECT_ABORTED': 4\n        };\n\n        $WebSocket.prototype._normalCloseCode = 1000;\n\n        $WebSocket.prototype._reconnectableStatusCodes = [4000];\n\n        $WebSocket.prototype.safeDigest = function safeDigest(autoApply) {\n            if (autoApply && !this.scope.$$phase) {\n                this.scope.$digest();\n            }\n        };\n\n        $WebSocket.prototype.bindToScope = function bindToScope(scope) {\n            var self = this;\n            if (scope) {\n                this.scope = scope;\n                if (this.rootScopeFailover) {\n                    this.scope.$on('$destroy', function() {\n                        self.scope = $rootScope;\n                    });\n                }\n            }\n            return self;\n        };\n\n        $WebSocket.prototype._connect = function _connect(force) {\n            if (force || !this.socket || this.socket.readyState !== this._readyStateConstants.OPEN) {\n                this.socket = $websocketBackend.create(this.url, this.protocols);\n                this.socket.onmessage = _angular2.default.bind(this, this._onMessageHandler);\n                this.socket.onopen = _angular2.default.bind(this, this._onOpenHandler);\n                this.socket.onerror = _angular2.default.bind(this, this._onErrorHandler);\n                this.socket.onclose = _angular2.default.bind(this, this._onCloseHandler);\n                this.socket.binaryType = this.binaryType;\n            }\n        };\n\n        $WebSocket.prototype.fireQueue = function fireQueue() {\n            while (this.sendQueue.length && this.socket.readyState === this._readyStateConstants.OPEN) {\n                var data = this.sendQueue.shift();\n\n                this.socket.send(isString(data.message) || this.binaryType != 'blob' ? data.message : JSON.stringify(data.message));\n                data.deferred.resolve();\n            }\n        };\n\n        $WebSocket.prototype.notifyOpenCallbacks = function notifyOpenCallbacks(event) {\n            for (var i = 0; i < this.onOpenCallbacks.length; i++) {\n                this.onOpenCallbacks[i].call(this, event);\n            }\n        };\n\n        $WebSocket.prototype.notifyCloseCallbacks = function notifyCloseCallbacks(event) {\n            for (var i = 0; i < this.onCloseCallbacks.length; i++) {\n                this.onCloseCallbacks[i].call(this, event);\n            }\n        };\n\n        $WebSocket.prototype.notifyErrorCallbacks = function notifyErrorCallbacks(event) {\n            for (var i = 0; i < this.onErrorCallbacks.length; i++) {\n                this.onErrorCallbacks[i].call(this, event);\n            }\n        };\n\n        $WebSocket.prototype.onOpen = function onOpen(cb) {\n            this.onOpenCallbacks.push(cb);\n            return this;\n        };\n\n        $WebSocket.prototype.onClose = function onClose(cb) {\n            this.onCloseCallbacks.push(cb);\n            return this;\n        };\n\n        $WebSocket.prototype.onError = function onError(cb) {\n            this.onErrorCallbacks.push(cb);\n            return this;\n        };\n\n        $WebSocket.prototype.onMessage = function onMessage(callback, options) {\n            if (!isFunction(callback)) {\n                throw new Error('Callback must be a function');\n            }\n\n            if (options && isDefined(options.filter) && !isString(options.filter) && !(options.filter instanceof RegExp)) {\n                throw new Error('Pattern must be a string or regular expression');\n            }\n\n            this.onMessageCallbacks.push({\n                fn: callback,\n                pattern: options ? options.filter : undefined,\n                autoApply: options ? options.autoApply : true\n            });\n            return this;\n        };\n\n        $WebSocket.prototype._onOpenHandler = function _onOpenHandler(event) {\n            this._reconnectAttempts = 0;\n            this.notifyOpenCallbacks(event);\n            this.fireQueue();\n        };\n\n        $WebSocket.prototype._onCloseHandler = function _onCloseHandler(event) {\n            var self = this;\n            if (self.useApplyAsync) {\n                self.scope.$applyAsync(function() {\n                    self.notifyCloseCallbacks(event);\n                });\n            } else {\n                self.notifyCloseCallbacks(event);\n                self.safeDigest(true);\n            }\n            if (this.reconnectIfNotNormalClose && event.code !== this._normalCloseCode || this._reconnectableStatusCodes.indexOf(event.code) > -1) {\n                this.reconnect();\n            }\n        };\n\n        $WebSocket.prototype._onErrorHandler = function _onErrorHandler(event) {\n            var self = this;\n            if (self.useApplyAsync) {\n                self.scope.$applyAsync(function() {\n                    self.notifyErrorCallbacks(event);\n                });\n            } else {\n                self.notifyErrorCallbacks(event);\n                self.safeDigest(true);\n            }\n        };\n\n        $WebSocket.prototype._onMessageHandler = function _onMessageHandler(message) {\n            var pattern;\n            var self = this;\n            var currentCallback;\n            for (var i = 0; i < self.onMessageCallbacks.length; i++) {\n                currentCallback = self.onMessageCallbacks[i];\n                pattern = currentCallback.pattern;\n                if (pattern) {\n                    if (isString(pattern) && message.data === pattern) {\n                        applyAsyncOrDigest(currentCallback.fn, currentCallback.autoApply, message);\n                    } else if (pattern instanceof RegExp && pattern.exec(message.data)) {\n                        applyAsyncOrDigest(currentCallback.fn, currentCallback.autoApply, message);\n                    }\n                } else {\n                    applyAsyncOrDigest(currentCallback.fn, currentCallback.autoApply, message);\n                }\n            }\n\n            function applyAsyncOrDigest(callback, autoApply, args) {\n                args = arraySlice.call(arguments, 2);\n                if (self.useApplyAsync) {\n                    self.scope.$applyAsync(function() {\n                        callback.apply(self, args);\n                    });\n                } else {\n                    callback.apply(self, args);\n                    self.safeDigest(autoApply);\n                }\n            }\n        };\n\n        $WebSocket.prototype.close = function close(force) {\n            if (force || !this.socket.bufferedAmount) {\n                this.socket.close();\n            }\n            return this;\n        };\n\n        $WebSocket.prototype.send = function send(data) {\n            var deferred = $q.defer();\n            var self = this;\n            var promise = cancelableify(deferred.promise);\n\n            if (self.readyState === self._readyStateConstants.RECONNECT_ABORTED) {\n                deferred.reject('Socket connection has been closed');\n            } else {\n                self.sendQueue.push({\n                    message: data,\n                    deferred: deferred\n                });\n                self.fireQueue();\n            }\n\n            // Credit goes to @btford\n            function cancelableify(promise) {\n                promise.cancel = cancel;\n                var then = promise.then;\n                promise.then = function() {\n                    var newPromise = then.apply(this, arguments);\n                    return cancelableify(newPromise);\n                };\n                return promise;\n            }\n\n            function cancel(reason) {\n                self.sendQueue.splice(self.sendQueue.indexOf(data), 1);\n                deferred.reject(reason);\n                return self;\n            }\n\n            if ($websocketBackend.isMocked && $websocketBackend.isMocked() && $websocketBackend.isConnected(this.url)) {\n                this._onMessageHandler($websocketBackend.mockSend());\n            }\n\n            return promise;\n        };\n\n        $WebSocket.prototype.reconnect = function reconnect() {\n            this.close();\n\n            var backoffDelay = this._getBackoffDelay(++this._reconnectAttempts);\n\n            var backoffDelaySeconds = backoffDelay / 1000;\n            console.log('Reconnecting in ' + backoffDelaySeconds + ' seconds');\n\n            $timeout(_angular2.default.bind(this, this._connect), backoffDelay);\n\n            return this;\n        };\n        // Exponential Backoff Formula by Prof. Douglas Thain\n        // http://dthain.blogspot.co.uk/2009/02/exponential-backoff-in-distributed.html\n        $WebSocket.prototype._getBackoffDelay = function _getBackoffDelay(attempt) {\n            var R = Math.random() + 1;\n            var T = this.initialTimeout;\n            var F = 2;\n            var N = attempt;\n            var M = this.maxTimeout;\n\n            return Math.floor(Math.min(R * T * Math.pow(F, N), M));\n        };\n\n        $WebSocket.prototype._setInternalState = function _setInternalState(state) {\n            if (Math.floor(state) !== state || state < 0 || state > 4) {\n                throw new Error('state must be an integer between 0 and 4, got: ' + state);\n            }\n\n            // ie8 wat\n            if (!objectDefineProperty) {\n                this.readyState = state || this.socket.readyState;\n            }\n            this._internalConnectionState = state;\n\n            forEach(this.sendQueue, function(pending) {\n                pending.deferred.reject('Message cancelled due to closed socket connection');\n            });\n        };\n\n        // Read only .readyState\n        if (objectDefineProperty) {\n            objectDefineProperty($WebSocket.prototype, 'readyState', {\n                get: function get() {\n                    return this._internalConnectionState || this.socket.readyState;\n                },\n                set: function set() {\n                    throw new Error('The readyState property is read-only');\n                }\n            });\n        }\n\n        return function(url, protocols, options) {\n            return new $WebSocket(url, protocols, options);\n        };\n    }\n\n    // $WebSocketBackendProvider.$inject = ['$log'];\n    function $WebSocketBackendProvider($log) {\n        this.create = function create(url, protocols) {\n            var match = /wss?:\\/\\//.exec(url);\n\n            if (!match) {\n                throw new Error('Invalid url provided');\n            }\n\n            if (protocols) {\n                return new Socket(url, protocols);\n            }\n\n            return new Socket(url);\n        };\n\n        this.createWebSocketBackend = function createWebSocketBackend(url, protocols) {\n            $log.warn('Deprecated: Please use .create(url, protocols)');\n            return this.create(url, protocols);\n        };\n    }\n\n    _angular2.default.module('ngWebSocket', []).factory('$websocket', ['$rootScope', '$q', '$timeout', '$websocketBackend', $WebSocketProvider]).factory('WebSocket', ['$rootScope', '$q', '$timeout', 'WebsocketBackend', $WebSocketProvider]).service('$websocketBackend', ['$log', $WebSocketBackendProvider]).service('WebSocketBackend', ['$log', $WebSocketBackendProvider]);\n\n    _angular2.default.module('angular-websocket', ['ngWebSocket']);\n\n    exports.default = _angular2.default.module('ngWebSocket');\n    module.exports = exports['default'];\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-websocket/dist/angular-websocket.js\n ** module id = 159\n ** module chunks = 0\n **/"],"sourceRoot":""}